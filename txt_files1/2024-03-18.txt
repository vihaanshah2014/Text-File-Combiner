CS 214 / Processes
==================

Process - executes a program
    - program code
    - memory (stack, heap)
    - list of open files
    - process id (PID)
    - process group id (PGID)
    - session id

Process group - one or more processes
    - used to group together related processes
        e.g., all the processes in a pipeline
    - called a job when it is created by a shell command
        the shell tracks the process groups it creates and assigns them
        job numbers
    - one process group is in "the foreground"
        - meaning it receives input from the terminal
        - notably, ^C and ^Z signal every process in the foreground group

Session - groups together processes started in a single log-in session
    - all processes share a terminal
    - when you log out, all processes in the session receive HUP
        ("hang-up")
        


we create new processes using fork()

pid_t fork(void);

    fork creates a new process (the child)
    the child starts out as a clone of the current process (the parent)
    
    in the parent, fork returns the PID of the child
        (or -1 if fork failed)
    in the child, fork returns 0
    
both processes run concurrently (for now)

pid_t child = fork();
if (child == 0) {

    // in child 
    
    exit(...);
} else if (child == -1) {
    perror("huh?");
    exit(1);
}

// in parent

once you create a child process, you must wait for it to terminate

pid_t wait(int *wstatus);

    if a child process has terminated, immediately returns
    otherwise, block until a child process terminates
    
    returns the PID of the terminated child
    writes exit status information to wstatus
    
    once wait returns, we know the child has finished
    we must call wait() once for each time we call fork()
    
a process becomes a "zombie" when it terminates
    when its parent calls wait, it is removed from the process table

a process becomes an "orphan" when its parent terminates
    when an orphan terminates, it becomes an orphan zombie
    typically, the OS will have a process that "adopts" orphans



often, we want the child process to run another program

    int execl(char *path, ...);
    int execv(char *path, char **args);
    
    path says where to find the executable to run
    the remaining argument(s) determine argv in the new program

    execl("/usr/bin/sort", "sort", "my_file", NULL);
                            argv[0]   argv[1]   tells execl no more args
                    
    
    char *args[] = { "sort", "my_file", NULL };
    execv("/usr/bin/sort", args);

        array must have NULL as its last entry
    
    
on success, exec does not return!
    current program is discarded
    process begins executing specified program with fresh stack, heap

    some aspects carry over:
        same PID, PGID, SID, user, permissions, etc.
        same open files
            in particular, stdin, stdout, stderr remain open


if (fork() == 0) {
    // only in the child
    execl(...);
    // if we got here, exec failed
    perror(...);
    exit(EXIT_FAILURE);
}
// only in the parent
wait(&status);


    we don't get a lot of information from the exit status (8 bits)
    what if we could get the output from the child process?
    

int dup(int fd);
    duplicates a file descriptor
    creates a new file descriptor for an existing open file description

    both file descriptors can be used interchangeably
    both must be closed to close the file

int dup2(int oldfd, int newfd);
    duplicates a file descriptor
    the new fd will be the specified number
    if that number already describes an open file, it is closed
    
    
    int fd = open(some_file, O_WRONLY|O_TRUNC|O_CREAT, 0777);
    dup2(fd, STDOUT_FILENO);
    
        subsequently, writes to stdout will go to this file instead
        of the original stdout
        
a child process could use open and dup2 before calling exec
    the new program will get the file for stdout instead of using
    the parent's stdout


int pipe(int fd[2]);

int p[2];
pipe(p);
    on success, p will contain two file descriptors
        p[0] is the "read" end of a pipe
        p[1] is the "write" end of a pipe
        
    anything we write to the second file descriptor can be read from
    the first



int p[2];
pipe(p);   // FIXME check for failure

if (fork() == 0) { 
    // in child
    dup2(p[1], STDOUT_FILENO);
        // now stdout will write to the pipe
    close(p[0]);
    
    exec(...);
        // anything the new program writes to stdout
        // will be sent to the pipe;
        // when it terminates, the write end will be closed
}

close(p[1]);
    // note: the write end must be closed in both processes for
    // read to return EOF

// read from the pipe until EOF
while ((bytes = read(p[0], buf, BUFSIZE)) > 0) {
    ...
}

// wait for child to terminate
wait(NULL);



we can use as many pipes as we want
    e.g., one pipe for stdin, one for stdout
    
we can use this mechanism to pipe the output of one program to the
input of another


int p[2];
pipe(p);

if (fork() == 0) {
    close(p[0]);
    dup2(p[1], STDOUT_FILENO);
    exec(....)
}
if (fork() == 0) {
    close(p[1]);
    dup2(p[0], STDIN_FILENO);
    exec(...);
}
close(p[0]);
close(p[1]);
wait(NULL);
wait(NULL);

note that only two children are created


contrast with:

a = fork();
b = fork();

|
+---+
|   |
+-+ +-+
| | | |



next up: signals and multithreading
