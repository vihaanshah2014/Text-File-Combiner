CS 214 / Application protocol
=============================

Recap: basic sockets interface

Optional: getaddrinfo()
    used to loop up domain names and port numbers
    populates the struct sockaddr used with bind() and connect()
    simplifies writing programs that work with IPv4 and IPv6
    
Opening a connection to an existing listener over TCP:

    socket()
        - establishes socket abstraction
        - specifies address domain, socket type, and "protocol"
    connect()
        - establishes connection to remote host
    
    write()  - send data to remote host
    read()   - receive data from remote host
    
    close() - closes both sides of the connection
    shutdown() - used to close one side of the connection
    

Creating a listener to wait for connection requests (over TCP):

    note: use AI_PASSIVE flag when calling getaddrinfo()
        use NULL for the node name (indicates local host)

    socket()
    bind()
        - associates our socket with a port number on our host
    listen()
        - tells network interface we want to receive connection requests
    
    accept()
        - receive incoming connection request (block if none yet)
        - returns a new socket associated with the incoming connection
        
    read()
    write()
        - used to communicate with socket obtained from accept()
    

TCP connections
    incoming TCP packets indicate which connection they are part of using
        - local host:port
        - remote host:port
        
        
example:
    three machines: A (listener), B, C
    A binds its socket to port 10000
    B and C coincidentally also use 10000
    
        the A-B connection will have A:10000, B:10000
        the A-C connection will have A:10000, C:10000
        
    two machines: A (listener), B
    A binds its socket to 10000
    B opens two connections to A:10000
        these must have different port numbers on B
        e.g., 100, 101
    
        connection 1 is A:10000, B:100
        connection 2 is A:10000, B:101
        
listeners must bind() in order for other hosts to know how to establish
    the connection
    
connectors don't need to bind(), because it does not matter which port  
    they use, as long as it is not already in use
    
note: there must be some agreement on how clients can learn the port
number used by the server
    - this is usually specified by the protocol
    
fixed or "well known" port numbers are assigned by IANA
    (there is a range of port numbers that will never be assigned)
    

server structure
----------------

"one at a time"

    repeat forever:
        accept incoming connection
        communicate with peer
        close connection
        
    easy to write
    can only deal with one client at a time
    

one connection per process

    repeat forever:
        accept incoming connection
        fork child process
            in child: deal with connection

    allows multiple concurrent connections
    provides some insulation (one connection handler cannot crash server)
    cumbersome communication between parent and children
    
    problem: how to deal with zombies
        - install handler for SIGCHLD 
            handler uses waitpid() to clean up the specific zombie
            
        - set SIGCHLD to SIG_IGN
            prevents child processes from becoming zombies
            (they just disappear when they terminate)
            

one connection per thread

    repeat forever:
        accept incoming connection
        create new thread to handle connection
        detach thread
        
    allows multiple concurrent connections
    easily shared data among all connection handler threads
    minimal protection from infinite loops or crashes
    
    we might want to address signal handling
        signals sent to a multithreaded program will be handled
        by an undetermined thread
        - we can control this by setting signal masks per thread
        - e.g., SIGINT or SIGHUP being handled by primary thread
        
multiplexing

    fewer threads than connections
    problem: we don't know what events will happen next
        should we call accept() or read() on a particular socket?
        how do we avoid waiting unnecessarily
        
    solution: select() or poll() allow us to block on multiple
        file descriptors at once and wait until any of them are ready
        
    lower latency than using multiple threads
    more complicated to write
    makes it easy to specify timeouts
    

    
    


