CS 214 / Project, file IO
=========================

run-time error conditions
    not enough memory, freeing a bad pointer
    your library code must detect these error conditions and report them
    malloc() should return NULL (and print a message)
    free() should do nothing or terminate the program (and print a message)
    
    printing to standard error
        fprintf(stderr, ... )
        
correctness conditions
    how do you know that your code is good enough to submit?
    
    you will want to run tests to decide whether you wrote the library
        correctly
    
    testing strategy:
    1. determine several requirements your library must satisfy
        - library detects all required errors
        - malloc should allocate memory
        - free should deallocate memory
        
    2. figure out how to tell whether your requirements are satisfied
    3. write code with test cases
        - e.g., allocate the largest possible allocation and see
            if the next malloc fails
        - allocate all of memory, free it, allocate again
        
        
test client

----

int main(int argc, char **argv)
{
    int test = atoi(argv[1]);   // FIXME
    int n;
    char *p;
    
    switch (test) {
        case 1:
            int n;
            free(&n);
            break;
            
        case 2:
            p = malloc(25);
            free(p);
            free(p);
            break;
            
        case 3:
            p = malloc(25);
            free(p + 10);
            break;
            
        // more cases...
    }
    
    return EXIT_SUCCESS;
}
----



performance testing
    - tests the efficiency of your code
    
    memgrind.c measures the speed of your library
    
        general structure
            note time
            run test 50 times
            note time
            subtract start time from end time and divide by 50
            report average elapsed time in milliseconds
            

"black box" and "white box" testing

    black box testing uses the public interface of a library
        called black box because you can't see inside
        memtest.c is an example of a black box test
    
    white box testing uses internal (private) aspects of the library
        called white box because it isn't black box


helper functions in mymalloc.c should be declared static
    -> makes them private to mymalloc.c (unlinked)
    
problem: white box tests would like access to the unshared functions
    and the memory array

solution: in your white box test code, include mymalloc.c instead of
    linking


other helpful tools when debugging:

    - function that checks the integrity of the heap
        - do the sizes of the chunks add up to the size of the heap?
        - are all the sizes reasonable?
        - are there adjacent free blocks?
    
    - function that prints the structure of the heap
        - for each chunk, print its size and whether it is in use
        - and other information you find helpful


use make to make your life easier

    test: test-program
        ./test-program
        
    test2: test-program
        # save test program output
        ./test-program > test2.out
        # compare output with pre-existing reference output
        diff test2.out test2.ref

useful compiler options

    -g                     include debugging information (symbols)
    -Wall                  turn on (more) compiler warnings
    -std=c99               disable GCC extensions
    -Wvla                  warn for variable-length arrays
    -fsanitize=address     enable address sanitizer (ASan)
    -fsanitize=undefined   enable undefined behavior sanitizer (UBSan)
    
        -fsanitize=address,undefined
    
    -O      optimize code
    -O2     optimize code harder




Files
-----

In Unix, a file is a stream of bytes
    previous systems represented files as sequences of records
-> byte streams are more general, but require more work

Unix generalizes this concept to work with all byte streams
- actual files on disk
- console input/output
- other IO devices
- inter-process communication (IPC)
- network communication

all of these have the concept of a stream of bytes that can be
    read from and/or written to

there are some important distinctions
- some streams are read-only or write-only
- some streams have random access


C has two sets of file functions

from the C language standard
    fopen, fclose, fread, fwrite, fscanf, fprintf
    identify files using FILE *
    buffered

from POSIX
    open, close, read, write
    identify files using file descriptors (integers)
    not buffered
    lower-level
    more general
    
a file descriptor is a number that identifies an open file
    the run-time system maintains a table of all open files
    the file descriptor is an index into this table
    typically
        0 is standard input (STDIN_FILENO)
        1 is standard output (STDOUT_FILENO)
        2 is standard error (STDERR_FILENO)

    fileno() returns the file descriptor associated with a FILE
    fdopen() creates a FILE for a file descriptor
    
buffering
    reading or writing a file requires help from the OS
        user programs can't talk directly to hardware
        instead, we call the OS to access file data
        OS calls introduce overhead (need to context switch in the CPU)
    idea: request large number of bytes together
    a buffer is an array of bytes used to store data that is about
        to be sent from a file or has been received from a file
    we only call the OS when the buffer is full/empty
    
the C functions use FILE, which includes a buffer
    functions like getc() and putchar() read/write using the buffer
    -> only call the OS when the buffer is empty/full
    
the POSIX functions don't have a built-in buffer:
    instead, you provide your own buffer (typically a char array)
    
ssize_t 
read(
    int fd,       // file descriptor
    void *buf,    // address of buffer
    size_t bytes  // number of bytes in the buffer
)
// returns the number of bytes read
// returns 0 at end of file
// returns -1 on error


    
