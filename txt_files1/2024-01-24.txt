CS 214 / C Intro/Review
=======================

Office Hours:
	Monday and Thursday, 2:00 PM - 4:00 PM
	Hill 448

declarations and definitions
----------------------------

declaration says what something is, but does not create it
	e.g. a function prototype declares that a function exists
	
		int compare(double, double);
		extern int some_global;
		
	things that are declared but not defined can be referred to,
	the linker will be responsible for connecting the references to the
		actual definition (which must be provided somewhere)

definitions create the thing being described
	e.g., function definition, global variable definition
	
a given program can declare the same thing many times, but it must
be defined exactly once

every definition is an implicit declaration
- we often do not need to provide an explicit declaration

when might we need an explicit declaration?
- we want to reference something defined outside the current source file
- we want to reference something defined later in the same source file
	- maybe we want to organize code in some way
	- maybe we have mutual recursion
	
	
	int foo(int);
	
	int bar(int x) 
	{
		...
		foo(x)
		...
	}
	
	int foo(int x)
	{ ... bar(y) ... }


header files
------------

a header file is a C source file containing declarations

	header files usually end in .h
		stdio.h, stlib.h, unistd.h, string.h, pthread.h

header files should only contain declarations
	- function prototypes
	- extern variables (but globals are often bad style)
	- type declarations
	
typically, a header file will be included into multiple .c files

	#include "myheader.h"
		-- look for this file in the current directory
	#include <standardheader.h>
		-- look for this file in the "standard" location(s)

usual convention is:
	for each source.c you would have source.h


for example, a project may have
	main.c
	queue.h
	queue.c
	
		we would expect both .c files to include queue.h

the preprocessor
----------------

lines that begin with # are preprocessor directives

the C preprocessor is a separate program that runs through your
source code and makes changes prior to compilation

the #include directive literally includes the contents of the specified file
	all declarations in an included header file become part of the
	source file after preprocessing

	note: any file can be included, not just headers
		but using include for non-headers can be confusing


#define MACRO "hello"

	after this line in the source, the preprocessor will replace
		all MACRO tokens with "hello"
		
	reference to MACRO will be replaced, but not in string literals
		"MACRO"
	or larger tokens, MACROS

#define ARRAYLENGTH 128

{
	int x[ARRAYLENGTH];
	for (int i = 0; i < ARRAYLENGTH; i++) { ... }
}


#define NONZERO != 0

if (x NONZERO) { ... }


#define FOREACH(P) for (; P; P = P->next)

	struct node *p = ...
	FOREACH(p) { 
		... do stuff with p ...
	}
	=>
	for (; p; p = p->next) {
		... do stuff with p ...
	}

macros can have parameters

#define SQUARE(X) X * X

	y = SQUARE(x);
	=>
	y = x * x;
	
	y = 1 / SQUARE(a + b);
	=>
	y = 1 / a + b * a + b;
	
#define SQUARE(X) ((X) * (X))

	y = 1 / SQUARE(a + b);
	=>
	y = 1 / ((a + b) * (a + b));


#undefine ARRAYLENGTH
	- removes the definition of a currently declared macro
	- subsequent uses of this token will not be replaced
	- allows us to define the macro again, if we want


conditional compilation
- useful if we want to have slightly different versions of a program
  or library defined in the same file

#ifdef SOME_MACRO

	... code ...

#else
	
	... other code ...

#endif


#ifndef SOME_MACRO
...
#endif

#if SOME_MACRO < 5
...
#endif


example: having a DEBUG mode
	we can use a trick and a compiler option to enable/disable debugging
	printfs (and other stuff) without modifying our source code

#ifndef DEBUG
#define DEBUG 0 
#endif

if (DEBUG) printf("the value of x is %d\n", x);


gcc -DDEBUG
	tells the preprocessor to define DEBUG as 1
gcc -DDEBUG=2
	tells the preprocessor to define DEBUG as 2
	
	
the option -E tells GCC to preprocess your source and stop		


memory objects
--------------

all data is in memory
an object is a place in memory to store data

every variable is associated with an object
	the compiler keeps track of which object goes with each variable

some objects contain smaller objects (e.g., arrays, structs)

to make use of an object, we need to know its location (pointer) and
we need to know its type


we can create objects that are not associated with a variable

	malloc() allocates an object of a specified size
		dynamic allocation
		- a static analysis cannot tell us how many times we will call
			malloc() or what arguments we will give it (in general)

- how do we know how many bytes to request?

	types like int do not have one specified size
		it is architecture-dependent
		
	use sizeof() to learn the number of bytes needed for a type
	
	malloc(array_length * sizeof(int));
	malloc(sizeof(struct node));
	
	
- what kind of pointer does malloc() return?

	malloc returns a "void pointer"
		- pointer of no specified type

	void *malloc(size_t);


	int *array = (int *) malloc(arraysize * sizeof(int));

