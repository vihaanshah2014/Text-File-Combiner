CS 214 / C Intro/Review
=======================

the type system in C is minimal
    - primarily intended to guide code generation
        e.g., size of data, which instructions to use
    - provides some safety
        some type errors are detected at compile-time
        but many incorrect types will be silently converted
        
implicit "casting"
    int x = ...;
    
    ... x / 1.6;
        this implicitly casts x's value to float (or double)
        
        x = (int) ((double) x / 1.6);
    

basic types: integers, char, float, double

arrays: a contiguous sequence of values of some type
    array variables have a type and dimension
        type is used to guide code generation for indexing
        dimension is used to guide allocation  -- not index bounds checks

    int array_name[dimension];
    
    int array[5], array2[10], n, m;
        dimensions apply only to a single variable
        the type applies to all variables on the line

    int matrix[rows][cols];
        matrix is an array of dimension rows
        each element is an array of dimension cols
        each element of those are an int
        
    matrix[i][j]
        selects int with index j of the array with index i

C does not have a string type
    we use arrays of characters containing a terminator
    
    terminator character: the char with value 0
        0, '\0'
        this is distinct from '0'
        
    why have a terminator?
        allows us to store strings of various lengths in an array
        
    char *s = "string literal";
        s refers to a specific constant string in memory
        
    char s[] = "foo";
    char s[] = {'f', 'o', 'o', '\0'};
        declares and initializes a char array containing this string
        because we did not provide a dimension, s will have length 4
        (length of string plus one for the terminator)
    
    char t[16] = "foo";
        here, t has dimension 16 but only the first 4 chars are initialized
    
    char u[16] = "";

enum
----

useful for types with a discrete set of values

enum direction { north, south, east, west };

    declares a type called "enum direction"
    declares four "enumerators" 

enum direction heading = north;

switch (heading) {
    case north:
        ...
    case south:
        ...
    ...
}


these are implemented using integers internally
useful to document what you are doing



struct
------

used to bundle multiple values, possibly of different types

struct point {
    double x;
    double y;
};

struct point location;
location.x = 0.0;
location.y = 25;

struct point other_location = { 1, 2 };


void move(struct point p)
{
    p.x += 25;
    // this only affects the copy of p received by the function
}


struct point move(struct point p)
{
    p.x += 25;
    return p;
}

{
    struct point location = ...;
    
    location = move(location);
    
}


struct fields can be any type

struct triangle {
    struct point vertices[3];
    enum color background;
    ...
}

struct triangle triangles[200];

triangles[25].vertices[1].x;
    we can chain together array and field accesses as much as we need


unions
------

allows us to declare variables that could have different types

union intorfloat {
    int i;
    float f;
};

the declaration resembles a struct, but only one element is present
at a time

union intorfloat x;
    x could contain an int or a float

x.i = 15;

...

x.f = 2.3;  // overwrites the 15 in x.i

note: it is undefined what happens if you use the wrong variant to read
from the union

    x.i = 15;
    float y = x.f;  // undefined what value y gets
    
these have very limited uses


typedef
-------

lets me give a new name to an existing type

typedef existing_type new_name;

typedef struct point point;
    // now we can write
    point p;
    // instead of
    struct point p;

typedef double vector[3];
    means vector is a name for the type of arrays with 3 doubles
    
    vector v;
        // same as
    double v[3];

typedef int color;
    this is two names for the same type, not two types

    color r;
    color g;



typedef struct {
    int x;
    int y;
} point;



pointers
--------

every datum is stored somewhere in memory
    every location in memory has an address

a pointer is a value that represents an address

implications:
    every variable has an address
        we can obtain it using &
    every struct field and array element has an address
        &array[4]
        &p.x
    every function has an address
        writing a function name with no arguments obtains its address

when we work with pointers, we need to know the type of data they point to
pointer values are usually typed

    int *    // type of a pointer to an integer
    
int *p;
    // p holds an address that should point to an integer
int i;  
p = &i;
    // now p points to the location of i
*p = 5;
    // writes to the location whose address is stored in p
    // here, this changes the value of i
    
const int x = 5;




        






