CS 214 / Multitasking
=====================


Project II notes
----------------

- the dictionary is specified as an argument each time the program runs
    -> make no assumptions about dictionary length/content
    
- you are only resposible for handling ASCII characters (0-127)
    -> /usr/share/dict/words is unfortunately UTF-8, so some words have
       characters outside that range
    -> it is safe to ignore words with non-ASCII characters

- ctype.h has many useful functions/macros: isalpha(), isupper(), tolower()

- for our purposes, all characters are letters, whitespace, or other
    -> treat symbols, numbers, control characters like punctuation
    
- if you can't get all the features working, get as many as you can


Exam topics
-----------

C programming
    - general syntax
    - preprocessor, use of #include
    - standard library
    - helpful tools: gcc, make, man
        -> man (the manual) is divided into sections
            POSIX functions are in section 2
            C standard functions are in section 3
    - declarations and definitions
            function definition vs prototype
    - preprocessing vs compiling vs linking
        - how is linking used to support separate compilation?
    - types
        - char, int (various), float, double
        - struct, union, enum
        - arrays
        - pointers
        - sizeof()
            - array variable vs pointer to array
    - macros
        - macro expansion
        - considerations when defining macros with arguments 
            (recommended parentheses)
            
            #define SQUARE(X)  X * X
                    <- needs more parentheses, but where and why?

        - checking macro expansion with gcc -E
        - use of \ to continue definitions

Memory 
    - understanding all data as collections of bytes
    - pointer vs "pointee"
    - pointer types and pointer arithmetic
    - object location vs object content
        int a;   a vs &a 
        int *p;  p vs *p vs &p
    - use of malloc(), realloc(), and free()
        int *p = malloc(...);
        int *q = p;
        p = realloc(p, ...)
        *q   /// potentially use-after-free

Posix File IO
    - open(), close(), read(), write()
    - use of buffers
    - opendir(), readdir(), closedir()

File system
    - inode block vs data block
    - directory files
        - file names
    - "linking" files
        -> can a file have more than one name?
        -> can a directory be linked more than once?


0 = /
	.	0
	..	0
	foo	1

1 = /foo
	.	1
	..	0
	bar	2
	qux 4

2 = /foo/bar
	.	2
	..	1
	baz	3

3 = /foo/bar/baz
	.	3
	..	2

4 = /foo/qux
	.	4
	..	1
	

multitasking
------------

a task refers to the execution of a program
	- some program being executed
	- instruction pointer, registers, etc.

a multitasking system executes multiple tasks concurrently
	split time between multiple tasks
	
	keep CPU busy when a task is blocked
	improve responsiveness for programs with user interfaces
	take advantage of multiple CPUs (multiprocessing)
	
virtual memory/protected memory
	pointers in user programs are "logical addresses" ("virtual addresses")
	data in the memory bank is referred to using "physical addresses"
	
	the hardware and OS maintain a mapping of logical addresses to
		physical addresses, per process
	
	-> the same logical address will refer to different physical
		addresses in different processes
	-> one process cannot access another process's memory


scheduling
	when do tasks get to run?
	how long do tasks get to run?
	cooperative multitasking
		- tasks run until they block or explicitly yield control
	preemptive multitasking
		- tasks get a time slice and run until the slice ends
		


process
	- task
	- virtual memory space
	


pid_t fork(void);
	- creates a new process (the child) by cloning the current process
		(the parent)

	fork() returns 0 in the child
	fork() returns the PID of the child in the parent
	fork() returns -1 and sets errno if something went wrong


pid_t wait(int *status);
	- obtains exit information from a child process
		- blocks until a child finishes
		- returns immediately if a child has terminated
	on success, returns the PID of the child that has terminated
		and writes exit information into status
	on failure (e.g., no child processes), returns -1 and sets errno

the process table (in the OS) keeps track of running processes

	when a process terminates, it remains in the process table
		and becomes a "zombie"
	when the parent calls wait(), it "reaps" the zombie
	

if a parent dies before its child processes, the become "orphans"
	when an orphan terminates, it becomes a orphan zombie

	-> a designated OS process (usually init) will "adopt" orphans and
		wait for them to terminate



int execl(char *path, ..., NULL);
int execv(char *path, char **args);

	start executing a different program (replacing the current program)
	on success, does not return
	on failure, returns -1 and sets errno
	
execl("/path/to/program_file", "/path/to/program/file", "Arg1", "Arg2", NULL)
	first argument is path to executable file
	remaining arguments will be the contents of argv
	last argument is NULL
	
char *args[] = {"/foo", "bar", "baz", NULL};
execv("/foo", args);
	argument vector is an array of strings (pointers) concluding with NULL
	
parent forks child
	child calls exec to run a program
parent waits for child to terminate


exec() replaces the current program
	effectively clears memory
	PID remains the same
	open files remain open
		(unless they have O_CLOEXEC)
