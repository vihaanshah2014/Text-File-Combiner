CS 214 / Protocols
==================

Recap:
    in defining our protocol, we are specifying
    session layer
        - who establishes connections
        - when are they opened
        - when are they closed
        
    presentation layer
        - how messages are formatted
        - determining where one message ends and the next begins
    
    application layer
        - what messages can be sent
        - when and from whom messages are appropriate

rps protocol

    Client          Server
    initiate
    
        -- PLAY ->
        <- WAIT --
        
        <- BEGIN --
        -- MOVE ->
        <- RESULT --
        -- QUIT/CONTINUE ->


        
        
last time, we chose a minimal presentation:
    all messages are one byte
    

we skipped most discussion of error conditions

things that can go wrong
    - connection closes unexpectedly
    - garbage data / improperly formatted message
    - inappropriate message
    
there is no strategy for these that is appropriate in all situations


    - for rpsd, we can just close the connection and cancel the game
        rpsd = rock-paper-scissors daemon
            daemon - traditional Unix term for a server


once we allow multi-byte messages, we also have this problem
    - message arrives, but is incomplete
    
    
depending on our design, we may want more control over when threads
block waiting for input
    - if we don't care, we can just call read() until we get the rest
      of the message
      
    - the protocol may specify some limits, e.g. a message must arrive
        within 500 ms
        
        
consider code using poll() or select() to wait for incoming data
on multiple sockets
    - if data arrives on a socket, but it isn't a complete message,
        how should we handle it?
        - call read() again and block until more data arrives?
            -> no longer able to look for data on other sockets
        - stuff partial message in a buffer and call poll() again
            -> responsive to input on all sockets, more complicated


if we use one thread per connection, we avoid the need for poll()
    threads can just block on read()
    but we need a way to force threads to wake up
        -> e.g., we can send a signal to the thread
                pthread_kill()
                signals like SIGUSR1 and SIGUSR2 are unlikely to be
                sent by other processes



multi-byte messages
-------------------

allowing longer messages greatly increases the amount of data we can send

    e.g., messages can have parameters
        e.g., PLAY can include a protocol version, user names, etc.
        
    messages may be variable-length
    
we need a way to tell whether we have a complete message

    - we should not assume that a single call to read() will return
        a single message
        
        (it is common in testing to receive a single message at a time,
        which can lead to a false sense of security)

-> message format should make it obvious when a sequence of bytes
    encodes a complete message
    
approaches:
    fixed-length messages
    delimiters
        some byte sequence that indicates the end of a message
        
    explicit length indicator
        sequence towards the start of the message indicating how many
        additional bytes are coming
        
    delimiters and explicit length indicator
        additional security
        
        
        
example: PLAY mesage with variable-length user name

delimiter
    PUser Name|
    
    P|User Name||

message-specific delimiter
    P~~User Name~~
    
explicit length field
    P|9|User Name

length field + delimiter
    P|11|User Name||
    
we can use one length field even with multiple variable-length fields
    Z|15|Hello|Goodbye||


choice of delimiters may depend on what sort of data we are sending
    e.g., | isn't a good choice if our data will contain Unix commands
    
    we can get around reserved characters using escape sequences,
    but now we have to encode and decode the message fields



Revised RPS protocol

    PLAY <user name>
        P|<user name>||
        
    BEGIN <opponent name>
        B|<name>||
        
    MOVE
        M|<move name>||
        
    RESULT
        R|<result>|<move name>||
        
    QUIT
        Q
    CONTINUE
        C
    WAIT
        W
        
        
for responsiveness, separate recv_msg() into two functions
    refresh_handle()
        - calls read() and adds bytes to the handle's buffer
        - idea: use poll() to tell when data has arrived, then use
            refresh_handle() to receive the data
    
    
    parse_msg()
        - reads data that has already arrived (in the handle's buffer)
        - returns
             1 - if a complete message was found
             0 - if an incomplete message has arrived
            -1 - if the data is not a message
            
this design allows us to watch for incoming data on multiple sockets
using poll() while controlling when we block
    - e.g., we only block in poll()
    - we can check whether a complete message has arrived without blocking


        
        



