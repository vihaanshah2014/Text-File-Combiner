CS 214 / pthread
================

recap:
    a multithreaded process contains multiple tasks sharing a
        virtual memory (and therefore program code, globals, heap, etc.)
    

pthread - Posix API for writing multithreaded programs

when using pthreads, you must use the -pthread option

#include <pthread.h>



int pthread_create(
    pthread_t *thread_id,
    pthread_attr_t *attributes,
    void *(*function)(void *),
    void *argument)

on success, starts a new thread (task) within the current process
    the new thread will execute the specified function
    and pass it the provided argument
    
    the ID of the new thread will be written to *thread_id
    
    attributes can be used to specify certain options or features
        (use NULL for the defaults)
    
    returns 0

on failure, returns an error code (does not write to errno)
    
we can think of this as calling a function "in the background"

the function argument must be a function that takes a single void *
    and returns a void *


pthread_attr_t is an abstract data type used to specify features for
    a thread;
    
    int pthread_attr_init(pthread_attr_t *attr);
    various pthread_attr_getX() and pthread_attr_setX() functions
    to obtain/change the attributes
    

pthread_t may be an integer or a struct, so best to treat it as
    opaque data (just pass it to other functions)



int pthread_join(pthread_t thread_id, void **return_value);

    if the specified thread has not terminated, blocks until it has
    obtain the return value from the thread and write it to *return_value
    
    on success, return 0
    on failure, return an error code
    
    
void *worker(void *argument);

// our code
{
    pthread_t work_thread;
    arg_t argument = get_next_argument();
    ret_t *return_value;
    
    pthread_create(&work_thread, NULL, worker, argument);
    
    // do other things
    
    pthread_join(work_thread, &return_value);

    // at this point, the worker thread has completed and
    // the pointer it returned is stored in return_value
}
    

other functions of varying usefulness:

    pthread_t pthread_self(void);
        // obtain thread id of current thread
    
    void pthread_exit(void *retvalue);
        // terminates current thread & provides return value
        // (thread version of exit())
        
    int pthread_equal(pthread_t t1, pthread_t t2);
        // tests whether two thread IDs are the same
    
    int pthread_kill(pthread_t thread, int sig);
        // sends a signal to a thread
    
    int pthread_cancel(pthread_t thread);
        // tells a thread to terminate


a more complex example: start a bunch of threads, then wait for them
all to terminate



{
    pthread_t threads[5];
    int args[5];
    
    // spawn all child threads
    for (int i = 0; i < 5; i++) {
        args[i] = i;
        pthread_create(&threads[i], NULL, thread_function, &args[i]);
    }
    
    // wait for all threads to complete
    for (int i = 0; i < 5; i++) {
        pthread_join(threads[i], NULL);
    }
    
    // all subtasks have been completed
}



pthread_create() is analogous to fork()/exit()
pthread_join() is analogous to wait()
    
    
but: processes have a clear parent/child relationship
all threads are peers

    any thread can call pthread_join for another thread
    

sharing data safely
-------------------

sharing mutable data among multiple threads is inherently unsafe:
    data races

one solution: sequentialize access to shared data structures
    that is, only one thread can access the structure at a time


we can enforce sequential access using a mutex ("lock")


pthread_mutex_t - abstract struct

int pthread_mutex_init(pthread_mutex_t *lock, pthread_mutexattr_t *attrs);

int pthred_mutex_destroy(pthread_mutex_t *lock);



typedef struct {
    int balance;
    pthread_mutex_t lock;
} account_t;


void account_init(account_t *a, int initial)
{
    a->balance = initial;
    pthread_mutex_init(&a->lock, NULL);
}


void account_change(account_t *a, int difference)
{
    pthread_mutex_lock(&a->lock);
    
    // critical section
    a->balance += difference;
    
    pthread_mutex_unlock(&a->lock);
}


lock and unlock ensure* sequential access to balance
    (assuming we don't access the field in some other way)




void account_transfer(account_t *dst, account_t *src, int amount)
{
    account_change(src, -amount);
    account_change(dst, amount);
}

