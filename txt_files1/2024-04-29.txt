CS 214 / Review
===============

Final Exam: Monday, May 6
	On-line via Canvas
	Available for 24 hours
	Exam itself will be approx. 1.5 hours total

C programming
-------------

C syntax

types
    - integer types 
    - floating point
    - enums
    - structs
    - unions
    - arrays
    - pointers
    
C pointers
    address of data (run-time)
    type (compile-time)

    pointer types are used to generate appropriate code, but are
    forgotten after compilation
        given a pointer, there is no way to query what sort of data
        it refers to
        
    "void" pointers have no type information
        - they must be cast to a specific pointer type to be used
        - or we can use generic operations such as memcpy() 
            - but only if we know the size of the data

        - to use properly, we need to know (as programmers) what sort
          of data we are using, even if it is not expressed in the types

memory allocation/deallocation
    malloc() / calloc() / realloc() - reserve space on the heap
        the run-time system maintains some sort of data structure that
        tracks which portions of the heap are allocated or free
    
    free() - deallocates a previously allocated heap object

object vs data

    object - location in memory that can hold data
    value  - actual bytes stored in an object at some point in time
    
    an address identifies an object
    
    a pointer variable has an object that stores the address of
        another object
        
        &p  - address of the pointer variable itself
        p   - value of the pointer, address of the object it points to
        *p  - value of the object it points to
        
        int I[2];
        I[0] = 10;
        I[1] = 20;
        int * p;
        p = &I[0];

        
        ++(*p)  => 11, changes I[0] to 11
        *(++p)  => 20, changes p to &I[1]
        (*p)++  => 10, changes I[0] to 11
        *(p++)  => 10, changes p to &I[1]


Macros/Preprocessor

    the preprocessor changes C source code into C source code
    
    #define SECRET 20
    
    #define MEAN(X, Y)  ((X)/2 + (Y)/2)

    
        MEAN(a, b)   => ((a)/2 + (b)/2)
        
        MEAN(a + b, c)  => ((a+b)/2 + (c)/2)
        1/MEAN(a, b)    => 1/((a)/2 + (b)/2)


    #define FOO(X)  ((X)++/2)
    
    
        FOO(bar)   => ((bar)++/2)


Posix File IO
-------------

C (and Posix) model files as a stream of bytes
=> actually, many things can be treated as streams of bytes
    Posix uses the file interface to deal with many of these
    
        files on disk (open())
            - can include many "non-file" file-like things
                FIFOs, devices, terminals
        pipes (pipe())
        terminals
        sockets (socket(), accept())

    different streams offer different operations
        read()
        write()
        lseek()
     
streams are identified by "file descriptors"
    -> numbers that index into a table of open streams

Posix file operations are "unbuffered"
    we provide our own buffer, and get data as soon as we ask for it
    
    char buf[200];
    read(fd, buf, 200);  <- obtain up to 200 bytes
    
    read() and write() return the number of bytes read/written
        -> why?
        


C file operations are "buffered"
    the FILE struct includes a buffer of data from the stream
    calls to fscanf() read from the buffer, and call read() internally to
        refresh it
    
    calls to fprintf() write to the buffer, and call write() internally to
        flush it



File system
-----------

Files are identified by i-node number (and device number)
    
    every file has exactly 1 i-node and zero or more data nodes
    
    i-node stores data about the file
        size
        who owns it
        what permissions it has
        where its data are stored
        
            -> direct and single/double/triple indirect references
            allows for very large files
            keeps i-nodes with a small, fixed size
            fast access to all parts of the file

    => not included: file name
    
directory hierarchy

    a directory file maps names to i-nodes
    
    starting from the root directory, we can define a path to a file
    
        /directory/subdirectory/subsubdirectory/name
        
        "directory" in /
        "subdirectory" in /directory
        "subsubdirectory" in /directory/subdirectory
        "name" in /directory/subdirectory/subsubdirectory

    each directory entry that references an i-node is a "link"
    the number of links to a file is the number of entries it has
    
    files can be linked any number of times
    
    every directory is linked in at least two places
        -> its parent (via its name)
        -> itself (via .)
        
        -> from each of its subdirectories (via ..)


Processes
---------

a process is an abstraction that executes a program
    -> a virtual memory (containing instructions)
    -> current processor state (program counter, registers, etc.)

    "program plus state"


processes are identified by process id (PID)

to create a new process, call fork()
    - duplicates current process
    - new process (child) starts with same state as parent
        -> is about to return from the call to fork()
        -> all data in memory is copied
        -> all open files are now open in the child (as well as in the parent)

    "fork returns twice"
    
    
    returns 0 in the child, returns PID of child in the parent
    
after calling fork(), parent should (eventually) call wait()
    -> learn that child has terminated
    -> obtain exit status of child


execv(), execl()
    - change the current program
    - start executing a new program; abandon the current program
    - memory is effectively cleared
    - retain PID
    - open files (mostly) remain open
    
    "exec does not return"
    
common pattern

    if (fork() == 0) {
        // set up some stuff with files
        execl(...)
    }
    wait()


Signals
-------

mechanism to interrupt a process
-> asynchronous communication with a process

signal types are identified by number (usually written as constants)
    SIGINT, SIGTERM, SIGKILL, SIGCHLD, etc.
    
can be triggered by errors or sent by other processes

a process sets a "disposition" for each signal type
one of:
    terminate
    ignore
    call a handler function
    stop
    continue


handler functions can stop the process (by calling exit()) or
resume executing from the point where the signal was received (by returning)

    -> it is only safe to resume from non-error signals


    signal handlers can only call a subset of "safe" functions


we can decide whether system calls resume or stop if we get a signal


signal mask
    - set of signals that are "blocked"
    
    blocked signals are not delivered, but also are not discarded
    if the signal is later unblocked, any pending signals will be delivered


Multithreading
--------------

allows us the benefits of multitasking within a single process
-> single shared memory


benefits: easier communication
drawbacks: more need for coordination

data race
    multiple threads access a piece of data and at least one access is
    a write
        (without coordination)
    
C programs containing data races are undefined

avoid data races by coordinating

e.g., use mutual exclusion to enforce sequential access
    -> no uncoordinated access means no data races
    -> still can have nondeterministic behavior
    

pthread library

    pthread_create()
    pthread_join()
    
    pthread_mutex_t  - used to coordinate exclusive access
    pthread_cond_t   - allows thread to block until another thread says
                        it can continue

    pthread_barrier_t
    sem_t


atomic instructions

    to implement mutex, we need a way to perform multiple memory operations 
    such that no other thread/CPU can access it "in between"
    
    test-and-set   - in one step, check whether an object has a certain
        value and set it to something
    compare-and-swap
    
    
    var M;
    
    if (test-and-set(M, 1) == 0) {
        // we know no other thread saw M was 0 before we could set it to 1
    }
    
    => without hardware support for atomic instructions, no coordination
        between threads is possible

deadlock: 4-necessary conditions
    mutual exclusion
    hold and wait
    no preemption
    circular wait


Networking
----------

sending messages from one process on one device to another process on
    a different device
    -> these devices may not be directly connected to each other
    
"link layer" - communication between directly connected devices
"network layer" - communication between devices on the same network
    (e.g., the Internet)
"transport layer" - communication between specific processes
"application layer" - the actual messages


sockets interface - used to establish communication by applications

    socket - identified by file descriptor
        abstract interface that may be connected to the network
        
    socket() - creates new (unconnected) socket
    
    connect() - connects a socket to a specified remote host/service
    
    bind() - connects a socket to a service on the local host
    listen() - indicates we want to accept incoming connection request
    accept() - waits for a connection request, returns a new socket
        handling the connection


there are many kinds of socket
sockets created with SOCK_STREAM will present a stream interface
    that can be used with read() and write()


    transport will ensure that bytes we send are received and that
    the bytes we receive are in the proper order and not missing anything

points to consider:
    avoiding blocking
    know where your message boundaries are
    
    know which party establishes the connection
    know how messages are encoded
    
OSI model
    physical
    data link
    network
    transport
    session
    presentation
    application


