CS 214 / Introduction, C
========================

Systems Programming

David Menendez <davemm@cs.rutgers.edu>
    please put [CS214] in your subject line
    
Sections 01-04

Recitations should start next week; please look for an announcement

Please attend lecture and recitation
Come to office hours with questions

Programming with C
Working with Unix-style operating systems (Linux/Posix)
- File system
- Multitasking / process control
- Multithreading (pthread)
- Network communication (sockets)

Project-oriented class
- Three or four programming assignments
    Two-person assignments
    Why?
        - most of you will need to work with others in the future
        - opportunity to work with others
        
    tips
    - communication is key!
    - determine specific responsibilities
    - communicate clear goals
    
Reference compiler is GCC 11.4 - installed on the iLab
    GCC - GNU Compiler Collection
    GNU - GNU is Not Unix
    
    Make sure your code compiles executes correctly in the iLab
    before submitting!


Why C?
------

C is a relatively simple programming language
- gives good visibility into the lower-level aspects of the computer
- designed to run (and be compiled) on low-powered hardware


C vs Java
- similar syntax
- similar orientation

- different libraries

Java is an interpreted language
    java source code --javac--> "bytecode" --java--> execution
        MyCode.java -> MyCode.class
    

C is a compiled language
    myprogram.c --gcc--> myprogram
    
    compiler translates source code to machine code
        source code - text readable by humans
        machine code - binary instructions readable by the CPU

    "compile time" - translation process
        many errors are compile-time errors: bad syntax, types, etc
        "static analysis"
    
    "run time" - when your progam is executing
        some errors are run-time errors: bad arguments to function,
            division by zero, not being able to open a file, etc.
        "dynamic analysis"
        
    stages of compilation
        preprocessing - translates source code to other source code
        compilation - translates source code to machine code
        linking - combines my machine code with code from the standard
            library
            

gcc myprogram.c
    - compiles and links program and creates executable "a.out"

gcc myprogram.c -o myprogram
    - compiles and links program and creates executable "myprogram"

gcc -c myprogram.c
    - compiles program and creates "object file" myprogram.o
    
gcc myprogram.o mylibrary.o mydatastructure.o -o prog
    - links specified object files and creates executable "prog"


why separate compilation and linking?
it enables separate compilation

    we can split a large program into many source files
    each source file can be compiled separately
    all the object files can be linked afterward
    

Java has classes and objects
C has functions
    functions are named bits of code that you can call (with parameters)
    
implications:
    no implicit arguments (this)
    no polymorphism/no overloading

Java has a hierarchical name space
    classes have names like java.sun.foo.bar.Whatever
    
C has a flat name space
    all functions and global variables in a program must have unique names
    difficult to coordinate large projecst
        -- not an issue for us


Types
-----

C has a small set of built-in types
    integers
        signed or unsigned
        "regular", short, or long
            - C does not mandate specific lengths
            - short int is at least 2 bytes
            - int is at least as big as a short int
            - long int is at least as big as an int
            - long int is bigger than short int
    signed and unsigned char
        ASCII is a standard mapping of integers to "characters"
        these are one byte
        'A' == 65
        '\n'
        
    floating-point: float and double
        in practice, always use double

    arrays - arrays in C are a state of mind
        an array of ints is just a bunch of adjacent ints in memory
        arrays do not track their length!
            there is no bounds-checking in C
            if you don't know the length of an array, you should have
                kept track of it


    array variables
        int a[5]; 
            // a is an array of 5 integers
            // a is managed by the run-time system
            // contents of a are undetermined
            
        a[0] - accesses the first element of a
        
        int b[5] = { 1, 2, 3, 4, 5 };
        
            curly braces can only be used in variable initialization
            
        int c[] = { 1, 2, 3, 4, 5 };
            c has length 5 implicitly
            
        int d[20] = { 1, 2, 3, 4, 5 };
            array has 20 elements
            first five are initialized
            remainder are uninitialized


        










