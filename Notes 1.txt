CS 214 / Introduction, C
========================

Systems Programming

David Menendez <davemm@cs.rutgers.edu>
    please put [CS214] in your subject line
    
Sections 01-04

Recitations should start next week; please look for an announcement

Please attend lecture and recitation
Come to office hours with questions

Programming with C
Working with Unix-style operating systems (Linux/Posix)
- File system
- Multitasking / process control
- Multithreading (pthread)
- Network communication (sockets)

Project-oriented class
- Three or four programming assignments
    Two-person assignments
    Why?
        - most of you will need to work with others in the future
        - opportunity to work with others
        
    tips
    - communication is key!
    - determine specific responsibilities
    - communicate clear goals
    
Reference compiler is GCC 11.4 - installed on the iLab
    GCC - GNU Compiler Collection
    GNU - GNU is Not Unix
    
    Make sure your code compiles executes correctly in the iLab
    before submitting!


Why C?
------

C is a relatively simple programming language
- gives good visibility into the lower-level aspects of the computer
- designed to run (and be compiled) on low-powered hardware


C vs Java
- similar syntax
- similar orientation

- different libraries

Java is an interpreted language
    java source code --javac--> "bytecode" --java--> execution
        MyCode.java -> MyCode.class
    

C is a compiled language
    myprogram.c --gcc--> myprogram
    
    compiler translates source code to machine code
        source code - text readable by humans
        machine code - binary instructions readable by the CPU

    "compile time" - translation process
        many errors are compile-time errors: bad syntax, types, etc
        "static analysis"
    
    "run time" - when your progam is executing
        some errors are run-time errors: bad arguments to function,
            division by zero, not being able to open a file, etc.
        "dynamic analysis"
        
    stages of compilation
        preprocessing - translates source code to other source code
        compilation - translates source code to machine code
        linking - combines my machine code with code from the standard
            library
            

gcc myprogram.c
    - compiles and links program and creates executable "a.out"

gcc myprogram.c -o myprogram
    - compiles and links program and creates executable "myprogram"

gcc -c myprogram.c
    - compiles program and creates "object file" myprogram.o
    
gcc myprogram.o mylibrary.o mydatastructure.o -o prog
    - links specified object files and creates executable "prog"


why separate compilation and linking?
it enables separate compilation

    we can split a large program into many source files
    each source file can be compiled separately
    all the object files can be linked afterward
    

Java has classes and objects
C has functions
    functions are named bits of code that you can call (with parameters)
    
implications:
    no implicit arguments (this)
    no polymorphism/no overloading

Java has a hierarchical name space
    classes have names like java.sun.foo.bar.Whatever
    
C has a flat name space
    all functions and global variables in a program must have unique names
    difficult to coordinate large projecst
        -- not an issue for us


Types
-----

C has a small set of built-in types
    integers
        signed or unsigned
        "regular", short, or long
            - C does not mandate specific lengths
            - short int is at least 2 bytes
            - int is at least as big as a short int
            - long int is at least as big as an int
            - long int is bigger than short int
    signed and unsigned char
        ASCII is a standard mapping of integers to "characters"
        these are one byte
        'A' == 65
        '\n'
        
    floating-point: float and double
        in practice, always use double

    arrays - arrays in C are a state of mind
        an array of ints is just a bunch of adjacent ints in memory
        arrays do not track their length!
            there is no bounds-checking in C
            if you don't know the length of an array, you should have
                kept track of it


    array variables
        int a[5]; 
            // a is an array of 5 integers
            // a is managed by the run-time system
            // contents of a are undetermined
            
        a[0] - accesses the first element of a
        
        int b[5] = { 1, 2, 3, 4, 5 };
        
            curly braces can only be used in variable initialization
            
        int c[] = { 1, 2, 3, 4, 5 };
            c has length 5 implicitly
            
        int d[20] = { 1, 2, 3, 4, 5 };
            array has 20 elements
            first five are initialized
            remainder are uninitialized


        











CS 214 / C Intro/Review
=======================

the type system in C is minimal
    - primarily intended to guide code generation
        e.g., size of data, which instructions to use
    - provides some safety
        some type errors are detected at compile-time
        but many incorrect types will be silently converted
        
implicit "casting"
    int x = ...;
    
    ... x / 1.6;
        this implicitly casts x's value to float (or double)
        
        x = (int) ((double) x / 1.6);
    

basic types: integers, char, float, double

arrays: a contiguous sequence of values of some type
    array variables have a type and dimension
        type is used to guide code generation for indexing
        dimension is used to guide allocation  -- not index bounds checks

    int array_name[dimension];
    
    int array[5], array2[10], n, m;
        dimensions apply only to a single variable
        the type applies to all variables on the line

    int matrix[rows][cols];
        matrix is an array of dimension rows
        each element is an array of dimension cols
        each element of those are an int
        
    matrix[i][j]
        selects int with index j of the array with index i

C does not have a string type
    we use arrays of characters containing a terminator
    
    terminator character: the char with value 0
        0, '\0'
        this is distinct from '0'
        
    why have a terminator?
        allows us to store strings of various lengths in an array
        
    char *s = "string literal";
        s refers to a specific constant string in memory
        
    char s[] = "foo";
    char s[] = {'f', 'o', 'o', '\0'};
        declares and initializes a char array containing this string
        because we did not provide a dimension, s will have length 4
        (length of string plus one for the terminator)
    
    char t[16] = "foo";
        here, t has dimension 16 but only the first 4 chars are initialized
    
    char u[16] = "";

enum
----

useful for types with a discrete set of values

enum direction { north, south, east, west };

    declares a type called "enum direction"
    declares four "enumerators" 

enum direction heading = north;

switch (heading) {
    case north:
        ...
    case south:
        ...
    ...
}


these are implemented using integers internally
useful to document what you are doing



struct
------

used to bundle multiple values, possibly of different types

struct point {
    double x;
    double y;
};

struct point location;
location.x = 0.0;
location.y = 25;

struct point other_location = { 1, 2 };


void move(struct point p)
{
    p.x += 25;
    // this only affects the copy of p received by the function
}


struct point move(struct point p)
{
    p.x += 25;
    return p;
}

{
    struct point location = ...;
    
    location = move(location);
    
}


struct fields can be any type

struct triangle {
    struct point vertices[3];
    enum color background;
    ...
}

struct triangle triangles[200];

triangles[25].vertices[1].x;
    we can chain together array and field accesses as much as we need


unions
------

allows us to declare variables that could have different types

union intorfloat {
    int i;
    float f;
};

the declaration resembles a struct, but only one element is present
at a time

union intorfloat x;
    x could contain an int or a float

x.i = 15;

...

x.f = 2.3;  // overwrites the 15 in x.i

note: it is undefined what happens if you use the wrong variant to read
from the union

    x.i = 15;
    float y = x.f;  // undefined what value y gets
    
these have very limited uses


typedef
-------

lets me give a new name to an existing type

typedef existing_type new_name;

typedef struct point point;
    // now we can write
    point p;
    // instead of
    struct point p;

typedef double vector[3];
    means vector is a name for the type of arrays with 3 doubles
    
    vector v;
        // same as
    double v[3];

typedef int color;
    this is two names for the same type, not two types

    color r;
    color g;



typedef struct {
    int x;
    int y;
} point;



pointers
--------

every datum is stored somewhere in memory
    every location in memory has an address

a pointer is a value that represents an address

implications:
    every variable has an address
        we can obtain it using &
    every struct field and array element has an address
        &array[4]
        &p.x
    every function has an address
        writing a function name with no arguments obtains its address

when we work with pointers, we need to know the type of data they point to
pointer values are usually typed

    int *    // type of a pointer to an integer
    
int *p;
    // p holds an address that should point to an integer
int i;  
p = &i;
    // now p points to the location of i
*p = 5;
    // writes to the location whose address is stored in p
    // here, this changes the value of i
    
const int x = 5;




        







CS 214 / C Intro/Review
=======================

Office Hours:
	Monday and Thursday, 2:00 PM - 4:00 PM
	Hill 448

declarations and definitions
----------------------------

declaration says what something is, but does not create it
	e.g. a function prototype declares that a function exists
	
		int compare(double, double);
		extern int some_global;
		
	things that are declared but not defined can be referred to,
	the linker will be responsible for connecting the references to the
		actual definition (which must be provided somewhere)

definitions create the thing being described
	e.g., function definition, global variable definition
	
a given program can declare the same thing many times, but it must
be defined exactly once

every definition is an implicit declaration
- we often do not need to provide an explicit declaration

when might we need an explicit declaration?
- we want to reference something defined outside the current source file
- we want to reference something defined later in the same source file
	- maybe we want to organize code in some way
	- maybe we have mutual recursion
	
	
	int foo(int);
	
	int bar(int x) 
	{
		...
		foo(x)
		...
	}
	
	int foo(int x)
	{ ... bar(y) ... }


header files
------------

a header file is a C source file containing declarations

	header files usually end in .h
		stdio.h, stlib.h, unistd.h, string.h, pthread.h

header files should only contain declarations
	- function prototypes
	- extern variables (but globals are often bad style)
	- type declarations
	
typically, a header file will be included into multiple .c files

	#include "myheader.h"
		-- look for this file in the current directory
	#include <standardheader.h>
		-- look for this file in the "standard" location(s)

usual convention is:
	for each source.c you would have source.h


for example, a project may have
	main.c
	queue.h
	queue.c
	
		we would expect both .c files to include queue.h

the preprocessor
----------------

lines that begin with # are preprocessor directives

the C preprocessor is a separate program that runs through your
source code and makes changes prior to compilation

the #include directive literally includes the contents of the specified file
	all declarations in an included header file become part of the
	source file after preprocessing

	note: any file can be included, not just headers
		but using include for non-headers can be confusing


#define MACRO "hello"

	after this line in the source, the preprocessor will replace
		all MACRO tokens with "hello"
		
	reference to MACRO will be replaced, but not in string literals
		"MACRO"
	or larger tokens, MACROS

#define ARRAYLENGTH 128

{
	int x[ARRAYLENGTH];
	for (int i = 0; i < ARRAYLENGTH; i++) { ... }
}


#define NONZERO != 0

if (x NONZERO) { ... }


#define FOREACH(P) for (; P; P = P->next)

	struct node *p = ...
	FOREACH(p) { 
		... do stuff with p ...
	}
	=>
	for (; p; p = p->next) {
		... do stuff with p ...
	}

macros can have parameters

#define SQUARE(X) X * X

	y = SQUARE(x);
	=>
	y = x * x;
	
	y = 1 / SQUARE(a + b);
	=>
	y = 1 / a + b * a + b;
	
#define SQUARE(X) ((X) * (X))

	y = 1 / SQUARE(a + b);
	=>
	y = 1 / ((a + b) * (a + b));


#undefine ARRAYLENGTH
	- removes the definition of a currently declared macro
	- subsequent uses of this token will not be replaced
	- allows us to define the macro again, if we want


conditional compilation
- useful if we want to have slightly different versions of a program
  or library defined in the same file

#ifdef SOME_MACRO

	... code ...

#else
	
	... other code ...

#endif


#ifndef SOME_MACRO
...
#endif

#if SOME_MACRO < 5
...
#endif


example: having a DEBUG mode
	we can use a trick and a compiler option to enable/disable debugging
	printfs (and other stuff) without modifying our source code

#ifndef DEBUG
#define DEBUG 0 
#endif

if (DEBUG) printf("the value of x is %d\n", x);


gcc -DDEBUG
	tells the preprocessor to define DEBUG as 1
gcc -DDEBUG=2
	tells the preprocessor to define DEBUG as 2
	
	
the option -E tells GCC to preprocess your source and stop		


memory objects
--------------

all data is in memory
an object is a place in memory to store data

every variable is associated with an object
	the compiler keeps track of which object goes with each variable

some objects contain smaller objects (e.g., arrays, structs)

to make use of an object, we need to know its location (pointer) and
we need to know its type


we can create objects that are not associated with a variable

	malloc() allocates an object of a specified size
		dynamic allocation
		- a static analysis cannot tell us how many times we will call
			malloc() or what arguments we will give it (in general)

- how do we know how many bytes to request?

	types like int do not have one specified size
		it is architecture-dependent
		
	use sizeof() to learn the number of bytes needed for a type
	
	malloc(array_length * sizeof(int));
	malloc(sizeof(struct node));
	
	
- what kind of pointer does malloc() return?

	malloc returns a "void pointer"
		- pointer of no specified type

	void *malloc(size_t);


	int *array = (int *) malloc(arraysize * sizeof(int));


CS 214 / Objects and Memory
===========================

An object is a location in memory where we can store data

Three categories
- static objects
	- global variables
	- string literals
	- code
- stack objects
	- local variables
	- other information about functions used by the runtime
- heap objects
	- created by calls to malloc()
	- destroyed by calls to free()
	- not associated with a variable

static objects exist the entire time the program runs:
	they are neither created nor destroyed

stack objects are associated with a particular function call
	created when the call begins
	destroyed when the call ends
	
the size of a heap object can be decided at run-time

any object can be referred to indirectly, using a pointer
only static and stack objects can be referred to directly
	(without a pointer)
	

to use an object, we need to know its address and its type
	the compiler tracks the types and locations of variables
	
	for indirect references:
		the value of the pointer says its address
		the type of the pointer indicates the type of object

pointer:
	a typed address (note: type is only known during compilation)
	
there is a special pointer: NULL
	NULL represents "no address"
	attempting to dereference NULL will cause a memory error

void pointers (void *)
	"untyped" pointers
	all we can do with these are 
		- compare for equality
		- cast to some other pointer type
			(it is your responsibility to make sure the type
			you cast to is reasonable!)
		- use with various functions

an example of void * shenanigans
	float f;
	void *v = &f;
	int *p = v;
	*p = 3;
	(do not do this)


arrays vs array variables

when we declare an array variable, we must specify the dimension
	int a[20];
		// a directly refers to an array object
	
	a by itself is effectively a pointer
	
		*a = 5;  is the same as a[0] = 5;
		
	we cannot reassign a to refer to a different array
	
	int b[30];
	a = b;      // nope
	
we can make pointers point to arrays

	int *p = a;
		// p is a pointer variable
		// it initially holds the address of a
		
	we can still use array indexing with p!
	
		p[1] = 20;   same as a[1] = 20
			also the same as *(p + 1) = 20
			also the same as *(a + 1) = 20
			but why use those when p[1] is more readable?

	this sort of indexing is only defined when
		- the pointer points to an array
		- the index is within the bounds of the array

	p = &a[5];
		now p[0] refers to the same int as a[5]
		p[1] is the same as a[6]
		p[-1] is the same as a[4]
		
pointer arithmetic

	if p points to something
	p+1 points to the "next thing" in memory
		(the actual address we get depends on the type of p)
		
	p-1 points to the "previous thing" in memory
	
	pointer arithmetic is only valid with pointers into an
		array, where the indexing leaves us within the array
		
pointer vs array variables
	array variables always point to a specific array
		pointer variables can be changed at any time
		
	pointer variables store their address at run-time
		array variables have a fixed address
		
	&a is the same as a
		&p is a pointer to a pointer variable
		
		
		
int n;
int *p = &n;
int **q = &p;

		n, *p, and **q all refer to the same object (n)


the heap
--------

use malloc() to create objects on the heap

	void *malloc(size_t);
	
	we tell malloc how many bytes we need
	malloc allocates an object and returns a pointer
		or returns NULL if it can't get enough space

int n = get_dimension_from_user();
int *p = malloc(n * sizeof(int));
	// we know that p points to an array of n ints (or NULL)
	// the compiler does not know this, but it trusts us


if malloc succeeded, we can treat p like any other array

	p[10] = p[5] + 1;
	
	
do we need to explicitly cast the pointer from malloc()?
	we aren't required to
	
int *p = malloc(size);            // ok
int *p = (int *) malloc(size);    // also ok


p = malloc(newsize * sizeof(int));           // ok
p = (int *) malloc(newsize * sizeof(int));   // maybe better?
	// the second one can protect me in case I use the wrong
	// pointer variable


nothing protects you from calling malloc with an incoherent size

double *p = malloc(dimension * sizeof(int));
	// probably a mistake

double *p;
...
p = malloc(dimension * sizeof(int));
	// probably a mistake, but harder to tell
	// an explicit cast here can make the mistake easier to find
	


struct node {
	data_t payload;
	struct node *next;
};

struct node *head = NULL;

void push(data_t item)
{
	struct node *new = malloc(sizeof(struct node));
	
	// (*new).payload = item;
	new->payload = item;
	new->next = head;
	head = new;
}

free() deallocates an object on the heap

	void free(void *);
	
	free can only be used with addresses returned by malloc()
	
	int *p, *q;
	
	p = malloc(20 * sizeof(int));
	q = p;
	
	what do we need to deallocate the array?
		1. free(p);
		2. free(q);
		3. free(p); free(q);

	1 and 2 both deallocate the array, because p and q hold
		the same pointer
	3 is wrong (double freeing)
	
	also wrong: free(p+10);
		p+10 points to a valid int object, but it isn't
			the object allocated by malloc()

int pop(data_t *dest)
{
	if (head == NULL) return 0;
	
	struct node *oldhead = head;
	if (dest)  *dest = head->payload;
	head = head->next;
	free(oldhead);
}

typedef struct node list_t;


typedef struct {
    data_t payload;
	list_t *next;    // doesn't work because list_t isn't defined yet
} list_t;

typedef struct node {
	data_t payload;
	struct node *next;
} list_t;





CS 214 / Generic memory operations
==================================

case study: sorting an array

    void sort_ints(int *array, int length);
    void sort_chars(char *array, int length);

what is the difference between these?
    - comparison function
    - size of the data units


what do we need to write a generic sorting function?
- some way to pass an array without restricting its type
    use void *

- some way to specify how to compare items
    use a function pointer
    return_type (*compare) (arg1_type, arg2_type, ...)
    
    int (*compare) (void *, void *)
    

int (*fun) (void *);   // fun is a pointer to a function
int *fun (void *);     // prototype for a function
    
    
- size of array elements



void sort(
    void *array,
    size_t array_length,
    size_t item_size,
    int (*comparison_function) (void *, void *)
);


copying memory
--------------

memcpy()  - copies a specified number of bytes from one location
            to another (locations cannot overlap)
            
    void *memcpy(void *dest, void *src, size_t size);
        copies size number of bytes from src to dest
        returns dest
    
    there are no safety checks!
        we must ensure that the source and destination objects
        are large enough (and that they are allocated)
    

    example: a and b are both arrays of 20 ints
    
    b = a;  // nope
    memcpy(b, a, sizeof(int) * 20);   // yes
    

memmove()  - copies a specified number of bytes from one location
             to another (locations may overlap)


    void *memmove(void *dest, void *src, size_t size);
    


strcpy()  - copies a string from one place to another

    char *strcpy(char *dest, char *src);


    note that no size is provided
        strcpy() copies from the source until it finds a terminator
        
    we need to make sure the source contains a string (w/terminator)
    we need to make sure the destination is large enough
    
    strcpy() needs to examine the data it copies, so it will
        never be faster than memcpy()
        - use memcpy() if you already know the length of a string
        
e.g., a common pattern for duplicating a string
    int len = strlen(src) + 1;
    char *dest = malloc(len);
    memcpy(dest, src, len);
    
    or just use strdup() if your compiler provides it


strncpy() - copies up to n bytes from a location to another

    char *strncpy(char *dest, char *src, size_t n);
    
    strncpy() copies a string, or the first n bytes
        -- if it stops before the end of the string, it doesn't
            write a terminator
            

strcat() - puts one string after the end of another string

    char *strcat(char *dest, char *src);
    char *strncat(char *dest, char *src, size_t n);
    
    src will be copied to dest starting at the terminator in dest
    (dest must have a terminator and enough space)
    
    strcat() always reads through dest, so repeatedly copying
    to a dest is quadratic time! (use pointers and memcpy())


memset()
calloc()
realloc()

----

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>



void sort(void *array, size_t alength, size_t esize,
    int (*compare) (const void *, const void *))
{
    char *base = array;
    void *temp = malloc(esize);


    for (int i = 0; i < alength; i++) {

    for (int j = 1; j < alength; j++) {
        char *prev = base + (j-1) * esize;
        char *this = base + j * esize;
        if (compare(prev, this) > 0) {
            // swap prev and this
            memcpy(temp, this, esize);
            memcpy(this, prev, esize);
            memcpy(prev, temp, esize);
        }

    }

    }

    free(temp);
}

int compare_ints(const void *x, const void *y)
{
    int a = * (int *) x;
    int b = * (int *) y;
    return a - b;
}

int compare_strings(const void *x, const void *y)
{
    char *a = *(char **)x;
    char *b = *(char **)y;
    return strcmp(a, b);
}


#define ALEN 5
#define BLEN 4

int main(int argc, char **argv)
{
    int A[] = { 7, 8, 0, -5, 20 };
    char *B[] = { "foo", "bar", "baz", "falala" };
        // note: B is an array of pointers (to strings)

    sort(A, ALEN, sizeof(int), compare_ints);
    sort(B, BLEN, sizeof(char *), compare_strings);

    for (int i = 0; i < ALEN; i++) {
        printf(" %d", A[i]);
    }
    printf("\n");

    for (int i = 0; i < BLEN; i++) {
        printf(" %s", B[i]);
    }
    printf("\n");

    return EXIT_SUCCESS;
}

CS 214 / ArrayList and make
===========================

Project I will be posted later tonight
We will discuss it in class Wednesday


ArrayList
---------

an array that we can expand or contract

- what sort of operations do we need to support?
    - push
    - pop
    - indexing
    
    - initialize
    - destroy

- we need the data structure itself
    - an array
    - number of elements in the list
    - size of the array

central idea:
    we add elements to the array until it is full
    when it is full, we replace the array with a bigger one



our project
    - test.c        - test driver (a client of ArrayList)
    - arraylist.c   - implementation of functions
    - arraylist.h   - type definition & function prototypes


compilation strategy
    compile arraylist.c -> arraylist.o
    compile test.c -> test.o
    link arraylist.o test.o -> test
    


changing the size of a heap object (sometimes)

void *realloc(void *, size_t);

    int *q = realloc(p, new_size);
        if realloc has enough space, q and p will point to the same address
        otherwise, q points to the new location and p is dead

    it is safest to assume that any object passed to realloc() has
    been moved
    - this can be a problem if we have multiple pointers into an object,
        because we need to update them all
        
    p = realloc(p, size);
        // sometimes considered an anti-pattern
        // if realloc() fails, it will return NULL and not free the
        //  original object  -- and now we no longer have a pointer


make
----

make is used to manage compiling our projects
we use a "makefile" to describe how to create certain files


<file to create>:   <list of dependencies>
	<commands to create the file> 
	
commands must be indented with a single tab character -- no spaces!


arraylist.o: arraylist.c arraylist.h
	gcc -c -Wall arraylist.c
	
test.o: test.c arraylist.h
	gcc -c -Wall test.c

test: test.o arraylist.o
	gcc test.o arraylist.o -o test



when make is called with no arguments, it will use the first recipe
in the makefile

you can also provide one or more specific targets to make

when make tries to create a target, it checks:
1. does a file by this name exist?
2. are all the dependencies (if any) up to date?
3. if the file exists and is older than any of its dependencies, execute
	the recipe


more advanced make
------------------

we can have variables in a makefile

to create a variable, write

VAR_NAME = some text

to use a variable, write $(VAR_NAME)

two commonly used variables that make can use

CC      - C compiler
CFLAGS  - options to give to C compiler

make uses these to create X.o files from X.c files, if no rule is given



CC = gcc
CFLAGS = -Wall -fsanitize=address -std=c99 -O2

test: test.o arraylist.o
	$(CC) $(CFLAGS) test.o arraylist.o -o test

arraylist.o: arraylist.c arraylist.h
	$(CC) $(CFLAGS) -c -Wall arraylist.c
	
test.o: test.c arraylist.h
	$(CC) $(CFLAGS) -c -Wall test.c


clean:
	rm *.o test



if we remove the rules for arraylist.o and test.o, make will use its
default rule for .o files


generalized recipes
-------------------

when make executes a recipe, it defines a few additional variables

    $@    - the name of the target we are creating
    $^    - the list of dependencies for the current target
    $<    - the first dependency of the current target
    
using these allows us to avoid repeating ourselves

test: test.o arraylist.o
	$(CC) $(CFLAGS) $^ -o $@
	

we can use % to create recipe patterns

%.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@

this says how to create any file ending in .o using a file ending with .c

if we provide a specific recipe, make will use that even if a wildcard
recipe exists


we can use rules with no commands to indicate additional dependencies

arraylist.o: arraylist.h
test.o: arraylist.h

or

arraylist.o test.o: arraylist.h



















CS 214 / Heap management
========================

Recitations start tonight
Project I group sign-up sheet on Canvas



Project I
---------

Errors to detect

1. attempt to malloc() too much memory
2. attempt to malloc() more memory than is currently available

3. attempt to free an address outside the heap
4. attempt to free an address of a non-allocated object
5. attempt to free an address in the heap but not of an object


#define MEMLENGTH 512
static double memory[MEMLENGTH];

using "static" makes the array private to this file
	(that is, it does not participate in linking)
	
we use "double" solely because it is 8 bytes and has 8-byte alignment



alignment
- primitive data types are at addresses that are multiples of their length
	- simplifies reading memory
	- prevents partial overlap
- how does malloc ensure alignment?
	- it has no way to distinguish an array of ints from an array of doubles
	- it always gives the maximum alignment for the hardware


suggestion: instead of using memory directly, cast it to a char pointer

#define heap ((char *) memory)

	heap + 128
	
reminder: we can cast pointers at any time


rounding up to multiples of 8

~7		-- all ones ending with 3 zeroes

n & ~7  -- rounds down to a multiple of 8

(n + 7) & ~7    -- rounds up to a multiple of 8


both header and payload sizes must be multiples of 8



your malloc implementation checks for incorrect use of free
-> this leads to a big performance hit

the real malloc/free are designed for speed
-> free is O(1) because it assumes its pointer is good


struct header {
	int allocated;
	int size;
};

(struct header *)(heap + 800)->allocated

(int *) (heap + 800)
(int *) (heap + 804)




CS 214 / Project, file IO
=========================

run-time error conditions
    not enough memory, freeing a bad pointer
    your library code must detect these error conditions and report them
    malloc() should return NULL (and print a message)
    free() should do nothing or terminate the program (and print a message)
    
    printing to standard error
        fprintf(stderr, ... )
        
correctness conditions
    how do you know that your code is good enough to submit?
    
    you will want to run tests to decide whether you wrote the library
        correctly
    
    testing strategy:
    1. determine several requirements your library must satisfy
        - library detects all required errors
        - malloc should allocate memory
        - free should deallocate memory
        
    2. figure out how to tell whether your requirements are satisfied
    3. write code with test cases
        - e.g., allocate the largest possible allocation and see
            if the next malloc fails
        - allocate all of memory, free it, allocate again
        
        
test client

----

int main(int argc, char **argv)
{
    int test = atoi(argv[1]);   // FIXME
    int n;
    char *p;
    
    switch (test) {
        case 1:
            int n;
            free(&n);
            break;
            
        case 2:
            p = malloc(25);
            free(p);
            free(p);
            break;
            
        case 3:
            p = malloc(25);
            free(p + 10);
            break;
            
        // more cases...
    }
    
    return EXIT_SUCCESS;
}
----



performance testing
    - tests the efficiency of your code
    
    memgrind.c measures the speed of your library
    
        general structure
            note time
            run test 50 times
            note time
            subtract start time from end time and divide by 50
            report average elapsed time in milliseconds
            

"black box" and "white box" testing

    black box testing uses the public interface of a library
        called black box because you can't see inside
        memtest.c is an example of a black box test
    
    white box testing uses internal (private) aspects of the library
        called white box because it isn't black box


helper functions in mymalloc.c should be declared static
    -> makes them private to mymalloc.c (unlinked)
    
problem: white box tests would like access to the unshared functions
    and the memory array

solution: in your white box test code, include mymalloc.c instead of
    linking


other helpful tools when debugging:

    - function that checks the integrity of the heap
        - do the sizes of the chunks add up to the size of the heap?
        - are all the sizes reasonable?
        - are there adjacent free blocks?
    
    - function that prints the structure of the heap
        - for each chunk, print its size and whether it is in use
        - and other information you find helpful


use make to make your life easier

    test: test-program
        ./test-program
        
    test2: test-program
        # save test program output
        ./test-program > test2.out
        # compare output with pre-existing reference output
        diff test2.out test2.ref

useful compiler options

    -g                     include debugging information (symbols)
    -Wall                  turn on (more) compiler warnings
    -std=c99               disable GCC extensions
    -Wvla                  warn for variable-length arrays
    -fsanitize=address     enable address sanitizer (ASan)
    -fsanitize=undefined   enable undefined behavior sanitizer (UBSan)
    
        -fsanitize=address,undefined
    
    -O      optimize code
    -O2     optimize code harder




Files
-----

In Unix, a file is a stream of bytes
    previous systems represented files as sequences of records
-> byte streams are more general, but require more work

Unix generalizes this concept to work with all byte streams
- actual files on disk
- console input/output
- other IO devices
- inter-process communication (IPC)
- network communication

all of these have the concept of a stream of bytes that can be
    read from and/or written to

there are some important distinctions
- some streams are read-only or write-only
- some streams have random access


C has two sets of file functions

from the C language standard
    fopen, fclose, fread, fwrite, fscanf, fprintf
    identify files using FILE *
    buffered

from POSIX
    open, close, read, write
    identify files using file descriptors (integers)
    not buffered
    lower-level
    more general
    
a file descriptor is a number that identifies an open file
    the run-time system maintains a table of all open files
    the file descriptor is an index into this table
    typically
        0 is standard input (STDIN_FILENO)
        1 is standard output (STDOUT_FILENO)
        2 is standard error (STDERR_FILENO)

    fileno() returns the file descriptor associated with a FILE
    fdopen() creates a FILE for a file descriptor
    
buffering
    reading or writing a file requires help from the OS
        user programs can't talk directly to hardware
        instead, we call the OS to access file data
        OS calls introduce overhead (need to context switch in the CPU)
    idea: request large number of bytes together
    a buffer is an array of bytes used to store data that is about
        to be sent from a file or has been received from a file
    we only call the OS when the buffer is full/empty
    
the C functions use FILE, which includes a buffer
    functions like getc() and putchar() read/write using the buffer
    -> only call the OS when the buffer is empty/full
    
the POSIX functions don't have a built-in buffer:
    instead, you provide your own buffer (typically a char array)
    
ssize_t 
read(
    int fd,       // file descriptor
    void *buf,    // address of buffer
    size_t bytes  // number of bytes in the buffer
)
// returns the number of bytes read
// returns 0 at end of file
// returns -1 on error


    

CS 214 / Posix File IO
======================

open
----

#include <fcntl.h>
int open(char *pathname, int flags);
int open(char *pathname, int flags, mode_t mode);

pathname: indicates where a file is located in the file system

    a name by itself (no slashes) refers to a file in the working directory
    a path with slashes indicates directory containment
    
        foo/bar/baz/quux indicates quux inside baz inside bar inside foo
            inside the working directory
    
    a path that begins with a slash is absolute: it starts from the
        filesystem root
        
    special directory entries:
        .. is the parent of the directory
        .  is the directory itself
        
    ../foo  means foo in the parent directory of the working directory
    
flags: bitmap indicating how we intend to use the file

    O_RDONLY   - open file for reading
    O_WRONLY   - open file for writing
    O_RDRW     - open file for reading and writing


additional flags (combine using |)

    O_CREAT   - create the file if it does not exist (must provide mode)
    O_TRUNC   - truncate file (set its length to 0) if it exists
    O_EXCL    - fail if the file already exists
    O_APPEND  - start writing from the end of the file
    O_NONBLOCK - open file in "non-blocking" mode (doesn't matter much for files on disk)

open returns a file descriptor when successful

if open cannot open the file, it returns -1 and sets errno

errno
-----

errno is a global variable that stores a number describing the last
    error that happened (from a function that sets errno)
-> not every function sets errno; check the documentation

the library defines constants for important error reasons; e.g., 

    EACCESS - don't have permission to access file
    EEXIST  - file already exists

and many, many others

instead of looking at errno directly, we will usually use perror() or
    strerror()
    
void perror(char *msg);

    prints an error message incorporating msg and describing the
        current value of errno
        
    int fd = open(filename, flags);
    if (fd == -1) {
        perror(filename);
        abort();
    }

char *strerror(int error_code);
    returns a string describing the given error code



file permissions
----------------

a file mode is the traditional Unix way to indicate who has what sort
    of access to a file

when opening a file with O_CREAT, you must specify the file mode
    (access permissions)!


three categories of users
    u  - the owner of a file (every file is owned by some user)
    g  - the group of a file (every file has access for some group)
    o  - everyone else

three forms of access
    r  - read access
    w  - write access
    x  - execute access (needed to run programs or read directories)

uuugggooo
rwxrwxrwx

chmod is a shell command that changes the mode of a file

    chmod <permissions code> <files...>
    
    chmod -w some_file   -- disable write permission
    chmod +r some_file   -- enable read permission
    
    chmod o-r  some_file   -- disable write permission for others


we can also use octal numbers to describe permissions

e.g.,   7 in octal is 111 in binary
        6 in octal is 110 in binary
        4 in octal us 100 in binary
        
we can use three octal digits to describe a permission setting

    644  rw-r--r--
    770  rwxrwx---
    
we can specify the mode parameter for open() using octal

    fd = open(file, O_WRONLY|O_CREAT|O_TRUNC, 0644);
        // creates file if it does not exist with permissions
        //      u+rw, g+r, o+r

    equivalent to:
    
        open(file, O_WRONLY|O_CREAT|O_TRUNC,
            S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);

reminder:
    integer literals (in C) beginning with 0 are in octal!
        010 == 8

        0111 == 64+8+1 


close
-----

#include <unistd.h>
int close(int fd);

    closes the specified file
    returns 0 on success
    returns -1 and sets errno on failure

note: all open files will be closed when the program exits
    either by the run-time system on normal exit, or by the OS


there is a limit to how many open files your process can have, so
    it is a good idea to close files when you are done with them
    
once a file is closed, its file descriptor may be reused by subsequent
    calls to open()


read
----


ssize_t read(int fd, void *buf, size_t n);

    reads from an open readable file
    up to n bytes
    bytes will be written to memory at buf
    
    returns the number of bytes obtained
    or 0, if you have reached the end of the file
    or -1 if something went wrong (errno set)


open files have the concept of a position or "file pointer"
    we start reading from the beginning of a file
    every time we read, the position advances
    
typical usage:

    char buf[BUFSIZE];
    
    int r = read(fd, buf, BUFSIZE);
    while (r > 0) {
        // do stuff with contents of buf
        r = read(fd, buf, BUFSIZE);
    }
    
    
or, if you don't like repeating yourself

    char buf[BUFSIZE];
    int r;
    
    while ((r = read(fd, buf, BUFSIZE)) > 0) {
        // do stuff with contents of buf
        for (i = 0; i < r; i++) {
            if (isspace(buf[i])) space_count++;
        }
    }


write
-----

ssize_t write(int fd, void *buf, size_t n);

    sends n bytes to a writable file
    fd indicates the file being written to
    buf holds the bytes we will write
    
    returns the number of bytes that were actually written
    returns -1 on error (and sets errno)
    


CS 214 / Reading files
======================

Late assignment submission:
    each day late, your score is reduced by 10 points
    this is not pro-rated
        if you can't make the deadline, get some sleep
    the late penalty will not reduce your score below 60

the README
    - both partners' names and netIDs
    - any additional information needed to compile and run your test cases
        - e.g., how to use your test program(s)
    - design notes
    - your test plan/testing strategy
    - description of your performance tests and why you chose them


Posix file IO
-------------

open() opens a file for reading and/or writing
    returns a file number (file descriptor)
    
read() obtains data from a file and writes it to memory
write() obtains data from memory and writes it to a file

read and write are system calls, so there is an overhead
    we use large buffers to amortize this cost
    

when we call read, we have to specify how much data to read (in bytes)

if we are reading a binary file, the format may indicate how many
bytes to read

    fd = open(data_file, O_RDONLY);
    if (fd < 0) { .... }
    
    int n;
    int *p;
    int bytes;
    
    bytes = read(fd, &n, sizeof(int));
    if (bytes < sizeof(int)) { ... }
    
    p = (int *) malloc(n * sizeof(int));
    bytes = read(fd, p, n * sizeof(int));
    if (bytes < n * sizeof(int)) { ... }
    


for text data, the units of data we are interested are variable-length
    (lines, words, etc.)

general idea: pick a buffer size,
    read that many bytes
    go through the buffer and look for units
    
    issues: buffer may contain a partial unit
        unit may be bigger than the buffer
        
        
Code examples posted on Canvas under Source Code/lines

CS 214 / Files & file system
============================

Reading a file has (at least) two parts:
    - read file and generate items of interest (producer)
    - making use of these items (consumer)

how can we organize a producer and consumer?

- don't make a distinction: same function reads files and uses items
    - simple to understand organization
    - no need to persist state (local variables are sufficient)
    - potentially complicated function
    - leads to code duplication

- producer-driven (enumerator)
    producer has main loop
        calls a function for the consumer each time an item is found

- consumer-driven (iterator)
    consumer has main loop
        calls a function to obtain the next item

- separate threads for producer and consumer
    requires multithreading
    more on this later
    

persistant vs ephemeral
- how long do the data items (e.g. strings) exist?
- who is responsible for deallocating them?

a persistent system creates items that live indefinitely
    - consumer must (eventually) deallocate them

an ephemeral system creats items that only live until the next item
    is produced
    - producer will deallocate them

difference between these is mostly a matter of preference
    - persistent system requires more allocation/deallocation
    - ephemeral system requires more discipline (can't use items once
        the next one is created)



file system
-----------

how do we refer to files?

at the user level, we refer to files by name (path)
    path describes how to find a file by listing all the directories
        that contain it
        
    /path/to/some/file

internally, files are identified by number (inode ID)
    this does not change if we move/rename a file
    
I-Node stores (some) metadata about a file
    - in Unix-style file systems, i-nodes are stored in an array
    - ID acts as an index into this array

the I-node says where to find the contents of the file on disk

requirements
    - fixed size for i-nodes (required for fast access)
    - we want to be able to represent very large files
    - we want to be able to represent small files efficiently
    - we can't require files be made of contiguous blocks
    - we want fast random access to every part of the file
    
solution:
    - locations of first 10 blocks are stored directly in i-node
    - single indirect
        e.g., a block containing references to the next 100 blocks
    - double indirect block
        e.g., a block containing references to 100 indirect blocks
            so 10,000 additional blocks
    - triple indirect block
        e.g., a block containing references to 100 double indirect blocks
            so 1,000,000 additional blocks

what else is stored in the i-node?
- size of the file (in bytes and in blocks)
- owner and group information and permissions
- timestamps (created, modified, accessed)


note that the file's name is not stored in the i-node
    -> after all, the i-node has limited space and file names can be long

file names are stored in the directories

a directory is a special file that stores information about files
    name (not path)
    i-node identifier
    maybe some other information
    
how to access a file /foo/bar/baz
    1. open / directory file (file system stores its location)
    2. scan that directory and look for "foo"
    3. open /foo directory file
    4. scan for "bar"
    5. open /foo/bar directory file
    6. scan for "baz"

when we call open("/foo/bar/baz", ...), the OS does this lookup for us

note that file names identify files, but are not part of the file itself

-> this allows us to have files with more than one name

ln <existing_file> <new_name>

    if we have a file foo and do
        ln foo bar
    now foo and bar both refer to the same i-node
    
the i-node tracks how many names refer to a file

when we remove a file, we unlink the name from the file
    this reduces the number of names for that file
    when the count reaches zero, the file is deleted
        (technically it is no names and no processes having it open)
        

symbolic links
--------------

"hard" links connect a file name to an i-node
"symbolic" or "soft" links connect a name to another name

a symbolic link is a special file that contains a path
    when you open a symbolic link, the OS will open the linked file instead


    ln -s <existing_file> <link_name>

unlike hard links, softlinks can be broken
    attempting to open a broken link will result in an error

if we replace a file with a new one with the same name, the soft link
    will refer to the new file
    

note: you can create soft links to directories
    new names for existing directories are usually not allowed
        (things like . and .. become ambiguous)
        
 




            



CS 214 / Directories
====================

Recap:
    a directory is a special file that contains directory entries
    each directory entry has (at a minimum)
        - file name
        - inode identifier

    every directory has two special entries
        .   - always refers to the directory itself
        ..  - always refers to the parent of the directory
        
two ways to open a directory file

    open()  - gives access to the raw bytes (not usually necessary)
    
    opendir()  - convenient way to iterate through directory entries
    
#include <dirent.h>

DIR *opendir(char *path);

    opens the specified directory and returns a handle
    on failure, returns NULL and sets errno
    
struct dirent *readdir(DIR *handle);

    returns the next entry in the directory
    returns NULL if we have read all the entries
    
    struct dirent contains at least these fields
        int_t d_ino;    // i-node identifier
        char d_name[];  // file name (null-terminated string)
        
    the pointer we get is only valid until the next call to readdir()
        or a call to closedir()

int closedir(DIR *handle);

    closes the specified open directory
    returns -1 and sets errno on failure



note: readdir() returns entries in no particular order
    (possibly the order that entries are stored in the directory file)


stat
----

int stat(char *path, struct stat *data);

    on success, fills out the specified struct with info about the file
    on failure, returns -1 and sets errno
    
    
struct stat contains information about the file, including
    dev_t st_dev;   // id of the device containing the file (disk)
    int_t st_ino;   // inode identifier for the file
    mode_t st_mode; // mode information (permissions, etc)


using the mode, we can learn things about the file including
    permissions
    file type
    
    
    S_ISREG(m)   - true for regular files
    S_ISDIR(m)   - directories
    S_ISLNK(m)   - symbolic links
    
struct stat sbuf;

int r = stat(pathname, &buf);
if (r < 0) { ... }

if (S_ISREG(buf.st_mode)) {
    // regular file
} else if (S_ISDIR(buf.st_mode)) {
    // directory
} else {
    ...
}

reference
    man 2 stat
    man 7 inode


the shell
---------

shell commands start with the command name
    bare name - look for a program in the specified directories
    path      - indicates a specific program

    cp  - will be found in /usr/bin
    /usr/bin/cp  - absolute path indicating program
    ./cp  - relative path (indicating cp in the working directory)
    
shell wildcards

    ?  - wildcard that can be replaced by any character
    *  - any sequence of zero or more characters (excluding /)
    
the shell replaces words containing a wildcard with files matching
    the word
    
example: current directory contains a.txt, b.txt, cd.txt

    ls ?.txt
        shell replaces this with
    ls a.txt b.txt
    
    ls *.txt
        shell replaces this with
    ls a.txt b.txt cd.txt

./spchk dict foo*.txt  

 subdir/*.c 
 
 subdir/*/*.c
 
 
 
mv <old_name> <new_name>

    either renames the first file or moves the file (if the new name is
        an already existing directory)

mv <many names...> <destination directory>


implication: we can't rename multiple files at once

    mv *.c *.cpp
        doesn't work!
        can't work!




    

    
    







CS 214 / Processes
==================

Midterm Exam: Wednesday, March 6, in class
    I will post a topic list and discuss it Monday
    You may bring 1 page (single sided) of handwritten notes
    
Format: primarily short answer questions (a few sentences at most)
    Some code reading, very little code writing


Project II will be due March 18


shell
-----

recall:
    search path used for first word in command (except for paths)
    
        prog    run a program "prog" in the search directories
        ./prog  run a program "prog" in the working directory

    PATH is the list of directories to search for programs


file globs
    specify one or more files
    
    * matches any sequence of characters
    ? matches any one character
    
    the shell expands globs before executing the program
    

stdin, stdout, stderr
    normally, these files are inherited from the shell 
        (or other parent process)
    
    redirection lets us change these
    
    some_program < foo
        use the file "foo" as standard input
        
    some_program > bar
        use the file "bar" as standard output
    
    some_program < foo > bar
        use "foo" as stdin and "bar" as stdout
    
    some_program >> bar
        use "bar" as stdout in append mode
        
    
    some_program 2> errs
        use "errs" as stderr
    
    some_program 3< foo 4> bar
        open "foo" for input as file number 3
        open "bar" for output as file number 4
        

## pipes

use pipes to chain two or more programs together,
    where the output of one program becomes the input of the next


    some_program | grep ERROR
    
        runs some_program and grep
        stdout for some_program writes to stdin for grep
        
    some_program | grep ERROR | sort | uniq -c


    some_program | tee file
    
        tee reads from stdin (the output of some_program)
        it sends what it reads to the file and to stdout

useful programs

wc - counts characters/words/lines in a file 

cat   - reads several files and writes them to stdout
more  - reads from a file or stdin and paginates its output
less  - more powerful version of more (lets you go backward)


    cat *.c | grep foo

    cat chapter*.txt > whole_thing.txt
    
grep - search files (or stdin) for lines matching a pattern

    grep ERROR files...
        print all lines containing ERROR    
    grep ^ERROR
        print all lines beginning with ERROR
    
    grep 'foo.*bar' files
        print lines containing "foo" followed at some point by "bar"

    grep "[0-9]" files
        print lines containing a digit

grep regular expressions are very powerful
many tutorials exist on-line


## exit status

    $?   - shell variable containing the exit status of the last process
    

foo && bar

    executes foo
    if foo succeeded, executes bar

    make prog && ./prog

foo || bar

    executes foo
    if foo failed, executes bar
    
    ./prog || echo "Failure!"
    

processes
---------

a process is a program that is being executed
    
    a process includes the state of the computer (memory, files, etc)
        as well as a program it is executing

    every process has a unique process ID (PID)
    

in Unix, a process group is a collection of one or more processes
    a process group created by a shell is a "job"
    
    running a single program starts a job
    all processes in a pipeline are part of the same job
    

a session is a set of process groups
    typically, each time you log into a system, you get a new login session
    every job and process you start will be part of this session


    a login session can be associated with a terminal
    
process groups can be in the foreground or the background


useful control codes:
    ^C   interrupts (terminates) every process in the foreground
        process group
    ^Z   stops (pauses) every process in the foreground progress group
        the parent becomes the foreground
        
        
fg   - brings a stopped job back to the foreground
bg   - resumes a stopped job in the background


jobs - lists all active jobs with their status
ps   - lists all processes in the current session

    ps -e   - lists all processes

put & at the end of a shell command to start the job in the background

    long_program > lp.out & 
    

    gedit file.c &
        <- run gedit in the background, so you can still use the shell


kill
    sends a signal to a process
    
    by default, sends TERM (tell process to terminate)

kill -KILL
kill -9
    kills a process with no opportunity to block


what happens to processes running in the background when I log out?

    they are sent HUP ("hang up")
    by default, a process receiving HUP will terminate

nohop shell command
    runs the shell command but blocks the hang-up signal
    
    nohup ./test_server
    

note: HUP, INT, TERM, and KILL terminate a program
    STOP stops a program
    a stopped program can be resumed, a terminated program cannot


creating processes
------------------

pid_t fork(void);

    creates an identical duplicate of the current process
    in the original process, fork() returns the PID of the new process
    in the child process, fork() returns 0


pid_t child = fork();
if (child == 0) {
    // we are in the child
    ...
    exit()
}

// we are in the parent


the child process begins as a duplicate of the parent:
    same program
    same contents of memory
    same instruction pointer 
    same open files
    different process ID
    
once fork returns, the parent and child will (most likely) diverge


after calling fork(), the parent must (eventually) call wait()

pid_t wait(int *wstatus);

    blocks until a child terminates
    returns PID of the child that terminated
    if we give it a pointer, it will write an int containing the exit status
    

puzzle:

    what does this do?
    
    for (int i = 0; i < 5; i++) {
        fork();
    }
    

    why is this a terrible idea?
    
    while (1) {
        fork();
    }








CS 214 / Multitasking
=====================


Project II notes
----------------

- the dictionary is specified as an argument each time the program runs
    -> make no assumptions about dictionary length/content
    
- you are only resposible for handling ASCII characters (0-127)
    -> /usr/share/dict/words is unfortunately UTF-8, so some words have
       characters outside that range
    -> it is safe to ignore words with non-ASCII characters

- ctype.h has many useful functions/macros: isalpha(), isupper(), tolower()

- for our purposes, all characters are letters, whitespace, or other
    -> treat symbols, numbers, control characters like punctuation
    
- if you can't get all the features working, get as many as you can


Exam topics
-----------

C programming
    - general syntax
    - preprocessor, use of #include
    - standard library
    - helpful tools: gcc, make, man
        -> man (the manual) is divided into sections
            POSIX functions are in section 2
            C standard functions are in section 3
    - declarations and definitions
            function definition vs prototype
    - preprocessing vs compiling vs linking
        - how is linking used to support separate compilation?
    - types
        - char, int (various), float, double
        - struct, union, enum
        - arrays
        - pointers
        - sizeof()
            - array variable vs pointer to array
    - macros
        - macro expansion
        - considerations when defining macros with arguments 
            (recommended parentheses)
            
            #define SQUARE(X)  X * X
                    <- needs more parentheses, but where and why?

        - checking macro expansion with gcc -E
        - use of \ to continue definitions

Memory 
    - understanding all data as collections of bytes
    - pointer vs "pointee"
    - pointer types and pointer arithmetic
    - object location vs object content
        int a;   a vs &a 
        int *p;  p vs *p vs &p
    - use of malloc(), realloc(), and free()
        int *p = malloc(...);
        int *q = p;
        p = realloc(p, ...)
        *q   /// potentially use-after-free

Posix File IO
    - open(), close(), read(), write()
    - use of buffers
    - opendir(), readdir(), closedir()

File system
    - inode block vs data block
    - directory files
        - file names
    - "linking" files
        -> can a file have more than one name?
        -> can a directory be linked more than once?


0 = /
	.	0
	..	0
	foo	1

1 = /foo
	.	1
	..	0
	bar	2
	qux 4

2 = /foo/bar
	.	2
	..	1
	baz	3

3 = /foo/bar/baz
	.	3
	..	2

4 = /foo/qux
	.	4
	..	1
	

multitasking
------------

a task refers to the execution of a program
	- some program being executed
	- instruction pointer, registers, etc.

a multitasking system executes multiple tasks concurrently
	split time between multiple tasks
	
	keep CPU busy when a task is blocked
	improve responsiveness for programs with user interfaces
	take advantage of multiple CPUs (multiprocessing)
	
virtual memory/protected memory
	pointers in user programs are "logical addresses" ("virtual addresses")
	data in the memory bank is referred to using "physical addresses"
	
	the hardware and OS maintain a mapping of logical addresses to
		physical addresses, per process
	
	-> the same logical address will refer to different physical
		addresses in different processes
	-> one process cannot access another process's memory


scheduling
	when do tasks get to run?
	how long do tasks get to run?
	cooperative multitasking
		- tasks run until they block or explicitly yield control
	preemptive multitasking
		- tasks get a time slice and run until the slice ends
		


process
	- task
	- virtual memory space
	


pid_t fork(void);
	- creates a new process (the child) by cloning the current process
		(the parent)

	fork() returns 0 in the child
	fork() returns the PID of the child in the parent
	fork() returns -1 and sets errno if something went wrong


pid_t wait(int *status);
	- obtains exit information from a child process
		- blocks until a child finishes
		- returns immediately if a child has terminated
	on success, returns the PID of the child that has terminated
		and writes exit information into status
	on failure (e.g., no child processes), returns -1 and sets errno

the process table (in the OS) keeps track of running processes

	when a process terminates, it remains in the process table
		and becomes a "zombie"
	when the parent calls wait(), it "reaps" the zombie
	

if a parent dies before its child processes, the become "orphans"
	when an orphan terminates, it becomes a orphan zombie

	-> a designated OS process (usually init) will "adopt" orphans and
		wait for them to terminate



int execl(char *path, ..., NULL);
int execv(char *path, char **args);

	start executing a different program (replacing the current program)
	on success, does not return
	on failure, returns -1 and sets errno
	
execl("/path/to/program_file", "/path/to/program/file", "Arg1", "Arg2", NULL)
	first argument is path to executable file
	remaining arguments will be the contents of argv
	last argument is NULL
	
char *args[] = {"/foo", "bar", "baz", NULL};
execv("/foo", args);
	argument vector is an array of strings (pointers) concluding with NULL
	
parent forks child
	child calls exec to run a program
parent waits for child to terminate


exec() replaces the current program
	effectively clears memory
	PID remains the same
	open files remain open
		(unless they have O_CLOEXEC)

CS 214 / Processes
==================

Process - executes a program
    - program code
    - memory (stack, heap)
    - list of open files
    - process id (PID)
    - process group id (PGID)
    - session id

Process group - one or more processes
    - used to group together related processes
        e.g., all the processes in a pipeline
    - called a job when it is created by a shell command
        the shell tracks the process groups it creates and assigns them
        job numbers
    - one process group is in "the foreground"
        - meaning it receives input from the terminal
        - notably, ^C and ^Z signal every process in the foreground group

Session - groups together processes started in a single log-in session
    - all processes share a terminal
    - when you log out, all processes in the session receive HUP
        ("hang-up")
        


we create new processes using fork()

pid_t fork(void);

    fork creates a new process (the child)
    the child starts out as a clone of the current process (the parent)
    
    in the parent, fork returns the PID of the child
        (or -1 if fork failed)
    in the child, fork returns 0
    
both processes run concurrently (for now)

pid_t child = fork();
if (child == 0) {

    // in child 
    
    exit(...);
} else if (child == -1) {
    perror("huh?");
    exit(1);
}

// in parent

once you create a child process, you must wait for it to terminate

pid_t wait(int *wstatus);

    if a child process has terminated, immediately returns
    otherwise, block until a child process terminates
    
    returns the PID of the terminated child
    writes exit status information to wstatus
    
    once wait returns, we know the child has finished
    we must call wait() once for each time we call fork()
    
a process becomes a "zombie" when it terminates
    when its parent calls wait, it is removed from the process table

a process becomes an "orphan" when its parent terminates
    when an orphan terminates, it becomes an orphan zombie
    typically, the OS will have a process that "adopts" orphans



often, we want the child process to run another program

    int execl(char *path, ...);
    int execv(char *path, char **args);
    
    path says where to find the executable to run
    the remaining argument(s) determine argv in the new program

    execl("/usr/bin/sort", "sort", "my_file", NULL);
                            argv[0]   argv[1]   tells execl no more args
                    
    
    char *args[] = { "sort", "my_file", NULL };
    execv("/usr/bin/sort", args);

        array must have NULL as its last entry
    
    
on success, exec does not return!
    current program is discarded
    process begins executing specified program with fresh stack, heap

    some aspects carry over:
        same PID, PGID, SID, user, permissions, etc.
        same open files
            in particular, stdin, stdout, stderr remain open


if (fork() == 0) {
    // only in the child
    execl(...);
    // if we got here, exec failed
    perror(...);
    exit(EXIT_FAILURE);
}
// only in the parent
wait(&status);


    we don't get a lot of information from the exit status (8 bits)
    what if we could get the output from the child process?
    

int dup(int fd);
    duplicates a file descriptor
    creates a new file descriptor for an existing open file description

    both file descriptors can be used interchangeably
    both must be closed to close the file

int dup2(int oldfd, int newfd);
    duplicates a file descriptor
    the new fd will be the specified number
    if that number already describes an open file, it is closed
    
    
    int fd = open(some_file, O_WRONLY|O_TRUNC|O_CREAT, 0777);
    dup2(fd, STDOUT_FILENO);
    
        subsequently, writes to stdout will go to this file instead
        of the original stdout
        
a child process could use open and dup2 before calling exec
    the new program will get the file for stdout instead of using
    the parent's stdout


int pipe(int fd[2]);

int p[2];
pipe(p);
    on success, p will contain two file descriptors
        p[0] is the "read" end of a pipe
        p[1] is the "write" end of a pipe
        
    anything we write to the second file descriptor can be read from
    the first



int p[2];
pipe(p);   // FIXME check for failure

if (fork() == 0) { 
    // in child
    dup2(p[1], STDOUT_FILENO);
        // now stdout will write to the pipe
    close(p[0]);
    
    exec(...);
        // anything the new program writes to stdout
        // will be sent to the pipe;
        // when it terminates, the write end will be closed
}

close(p[1]);
    // note: the write end must be closed in both processes for
    // read to return EOF

// read from the pipe until EOF
while ((bytes = read(p[0], buf, BUFSIZE)) > 0) {
    ...
}

// wait for child to terminate
wait(NULL);



we can use as many pipes as we want
    e.g., one pipe for stdin, one for stdout
    
we can use this mechanism to pipe the output of one program to the
input of another


int p[2];
pipe(p);

if (fork() == 0) {
    close(p[0]);
    dup2(p[1], STDOUT_FILENO);
    exec(....)
}
if (fork() == 0) {
    close(p[1]);
    dup2(p[0], STDIN_FILENO);
    exec(...);
}
close(p[0]);
close(p[1]);
wait(NULL);
wait(NULL);

note that only two children are created


contrast with:

a = fork();
b = fork();

|
+---+
|   |
+-+ +-+
| | | |



next up: signals and multithreading

CS 214 / Signals
================

Interrupts
----------

normal operation for the CPU is the "fetch-execute cycle"

    loop:
        obtain next instruction from memory
        decode instruction
        execute instruction
    
"interrupts" are a way to break out of this cycle

    stops fetch-execute cycle and saves state
    executes some other code (based on what kind of interrupt)
    that code may tell CPU to resume what it was doing before

used for many purposes
    - preemptive multitasking
    - dealing with errors (division by zero, segmentation violations, etc.)
    - handling incoming data
    - on some architectures, system calls
    - timers

key point: interrupts can happen at any time (asynchronous)


signals
-------

a way to communicate with a process asynchronously

- a process can receive a signal at any time
    - could be sent by OS, other processes, hardware

signals come in several types

    for each signal, there is a default "disposition"
    each process can override these dispositions
    
possible dispositions:

    - ignore
    - terminate
    - terminate and dump core
    - stop
    - call a signal handler
        - can terminate process
        - can execute code
        - can resume process

some common signals

SIGTERM   - default for the kill command
SIGINT    - sent by terminal after ^C
SIGHUP    - sent by terminal when user logs out
SIGQUIT   - sent by terminal after user types quit code

SIGKILL   - available from kill command (terminates program without recourse)

SIGABRT   - caused by abort()


SIGSTOP   - stops program
SIGTSTP   - stops program, sent by terminal after ^Z

SIGCONT   - continues stopped program

error conditions:

SIGFPE    - floating-point exception
SIGSEGV   - segmentation violation

man 7 signal
    - information about most signal types


two functions for changing a process's disposition for a signal type

#include <signal.h>

typedef void (*sighandler_t)(int);

sighandler_t signal(int signum, sighandler_t handler);

    takes a signal number (usually given with a macro like SIGHUP)
    and a pointer to a signal handler function,
        or one of two constants
    
        SIG_IGN   - set disposition to ignore
        SIG_DFL   - reset disposition to the default
    
    returns the previous disposition

    
example: ignoring SIGHUP

    signal(SIGHUP, SIG_IGN);
    
example: setting a handler function

    signal(SIGINT, int_handler);
    
    (but it is recommended to use sigaction() to set a handler function)


the more powerful function is sigaction()

int sigaction(int signum, struct sigaction *new, struct sigaction *old);

    uses new to set the disposition for signum
    if old is non-NULL, writes the current disposition to it
    
the sigaction struct allows us to specify a handler function
    (in one of two styles) and information about how the signal should
    be handled



signal handlers
---------------

a function that you never explicitly call

    - it is called asynchronously when its signal arrives

when the signal arrives, the interrupt logic in the OS simulates
a call to the signal handler
    - if the signal handler returns normally, the program will
      proceed from where it was before the signal arrived

this is problematic for signals caused by CPU errors (SIGFPE, SIGSEGV, etc.)
because the handler would return back to the same instruction that
triggered the signal
    - we must terminate the program, or use some method to skip ahead
        (in C, we can use setjmp() and longjmp() to make exception handlers)
    
not all functions are safe to call inside a signal handler

    most C IO functions are not allowed (printf, scanf, etc.)
    
    see man 7 signal-safety for a list of safe functions



what happens if you get a signal while you are in a signal handler?

you may want to do different things
    probably don't want the same signal handler to run
    
    temporarily restore the default disposition for that signal
    temporarily block the signal (and possibly other signals)


blocking a signal stops it from arriving, but allows it to arrive later
    (when that signal number is unblocked)

sigprocmask() allows us to learn/change the current "signal mask"
    (set of blocked signals)


sending a signal
----------------

"kill" on the command line

    kill [-SIGNAME] PID

we can specify a signal type, or get SIGTERM by default


int kill(pid_t pid, int signum);

    sends a signal to a specified process (or process group)


int raise(int signum);

    sends a signal to the current process



    






    










CS 214 / Multithreading
=======================

Threads
-------

"task" - instance of a fetch-execute cycle
    - has an instruction pointer, usually a stack

"process" - usually has one task
    - private virtual memory

a multitasking system can run more than one task concurrently
    can switch between multiple tasks on a single processor
    can schedule tasks between multiple processors (multiprocessing)


processes with separate virtual memories are protected from each other
but cannot easily communicate

"threads" - tasks within a single process
    a multithreaded process has multiple tasks sharing the same
        virtual memory

multithreading greatly simplifies communication between tasks
multithreading allows for miscommunication/interference between tasks


two major kinds of multithreading

"OS threads"/"kernel threads"
    - threads visible to OS
    - scheduling handled by OS
    - OS can schedule threads on separate processors


"green threads"/"library threads"/"language threads"
    - threading implemented within programming language 
    - process handles scheduling of its own threads
    - cannot take advantage of multiple processors
    - typically lower overhead than OS threads


Need for synchronization
------------------------

race condition
    - outcome of program depends on which thread finishes first
    - nondeterminism introduced by thread scheduling
    
        thread A        thread B
        --------        --------
        X = 1           X = 2
        
    program starts both threads, waits for both to finish, then
    prints X
        Does it print 1 or 2?
        Yes! Instead of a single outcome, we have a set of possible
        outcomes (nondeterminism)

data race
    - multiple threads making unsynchronized access to a piece of data,
        at least one of which writes to it
        
C programs containing data races are undefined!


    Thread A                                Thread B
    --------                                --------
    for (i = 0; i < 100; i++) {             X = 0
        X = 1;
        a[i] = X;
    }

101 possible outcomes, depending on when thread B runs  
    
    Thread A (optimized)
    --------------------
    X = 1;
    for (i = 0; i < 100; i++) {
        a[i] = X;
    }

101 possible outcomes, depending on when thread B runs
    -- with 2 exceptions, all of these are different from the
        optimized outcomes

we want to allow optimizations like these, so C declares data
    races to have undefined behavior

solution: don't have data races
    - forbid shared mutable data at language level (Rust)
    - synchronize access to shared data
        - enforce sequential access


for example, a memory fence is an instruction that pauses a thread
    until all pending writes have finished
    
    knowing when to use a memory fence can be difficult
    - using too many fences slows down our threads
    - not using the right fences can lead to data races
    
    compilers aren't (currently) smart enough to know where memory
        fences are needed
    typically, these are inserted in library code by experts


Tools for synchronization
-------------------------

mutual exclusion / "locks"
    idea: resources that at most one thread can access simultaneously


e.g., a shared queue
    only one thread can enqueue or dequeue at a time,
    but otherwise they can be scheduled freely


how can we make a lock?

int lock = 0;


example:
    while (lock == 1) { do nothing }
    lock = 1;
    // use shared resource
    lock = 0;

this doesn't work!
another thread could acquire the lock between exiting the loop and
    setting lock = 1
    
problem: the operation is not atomic
    other threads can be scheduled between the test and the set
    

one common solution: atomic hardware operations
    test-and-set
    compare-and-swap
    fetch-and-add

test-and-set is an atomic operation that checks the current value
of a variable and sets it

we can think of this as a function that sets a variable and returns
its old value

    while (test_and_set(&lock) == 1) { // do nothing }
    // do work
    lock = 0;
    


this sort of lock is called a "spinlock"
- horribly inefficient
- don't allow the scheduler to know when a thread is blocked by
    a lock
- requires a lot of bus traffic (needed to ensure the atomic nature
    of test-and-set)

instead of using spinlocks, we use higher-level system-provided
    mutex locks


The PThread (Posix Threads) library provides a mutex abstraction
that can be locked and unlocked

- only one thread can have a given lock at a time
- a thread attempting to lock a locked mutex will block until the
    mutex is unlocked


two operations: lock and unlock


    lock(&m);
    // do stuff    <-- critical section
    unlock(&m);

idea: enforce sequential access to shared data structures
only the thread holding the lock has access
    -> other threads must wait for that thread to finish before
        they can get access

C (Posix) gives us the tools to synchronize access to data
    structures, but it is up to us to use these tools correctly


nothing stops us from accessing a shared data structure without first
    getting exclusive access (except our own good sense)



next time:
    pthread_create
    pthread_join
    pthread_mutex_init
    pthread_mutex_lock
    pthread_mutex_unlock

CS 214 / pthread
================

recap:
    a multithreaded process contains multiple tasks sharing a
        virtual memory (and therefore program code, globals, heap, etc.)
    

pthread - Posix API for writing multithreaded programs

when using pthreads, you must use the -pthread option

#include <pthread.h>



int pthread_create(
    pthread_t *thread_id,
    pthread_attr_t *attributes,
    void *(*function)(void *),
    void *argument)

on success, starts a new thread (task) within the current process
    the new thread will execute the specified function
    and pass it the provided argument
    
    the ID of the new thread will be written to *thread_id
    
    attributes can be used to specify certain options or features
        (use NULL for the defaults)
    
    returns 0

on failure, returns an error code (does not write to errno)
    
we can think of this as calling a function "in the background"

the function argument must be a function that takes a single void *
    and returns a void *


pthread_attr_t is an abstract data type used to specify features for
    a thread;
    
    int pthread_attr_init(pthread_attr_t *attr);
    various pthread_attr_getX() and pthread_attr_setX() functions
    to obtain/change the attributes
    

pthread_t may be an integer or a struct, so best to treat it as
    opaque data (just pass it to other functions)



int pthread_join(pthread_t thread_id, void **return_value);

    if the specified thread has not terminated, blocks until it has
    obtain the return value from the thread and write it to *return_value
    
    on success, return 0
    on failure, return an error code
    
    
void *worker(void *argument);

// our code
{
    pthread_t work_thread;
    arg_t argument = get_next_argument();
    ret_t *return_value;
    
    pthread_create(&work_thread, NULL, worker, argument);
    
    // do other things
    
    pthread_join(work_thread, &return_value);

    // at this point, the worker thread has completed and
    // the pointer it returned is stored in return_value
}
    

other functions of varying usefulness:

    pthread_t pthread_self(void);
        // obtain thread id of current thread
    
    void pthread_exit(void *retvalue);
        // terminates current thread & provides return value
        // (thread version of exit())
        
    int pthread_equal(pthread_t t1, pthread_t t2);
        // tests whether two thread IDs are the same
    
    int pthread_kill(pthread_t thread, int sig);
        // sends a signal to a thread
    
    int pthread_cancel(pthread_t thread);
        // tells a thread to terminate


a more complex example: start a bunch of threads, then wait for them
all to terminate



{
    pthread_t threads[5];
    int args[5];
    
    // spawn all child threads
    for (int i = 0; i < 5; i++) {
        args[i] = i;
        pthread_create(&threads[i], NULL, thread_function, &args[i]);
    }
    
    // wait for all threads to complete
    for (int i = 0; i < 5; i++) {
        pthread_join(threads[i], NULL);
    }
    
    // all subtasks have been completed
}



pthread_create() is analogous to fork()/exit()
pthread_join() is analogous to wait()
    
    
but: processes have a clear parent/child relationship
all threads are peers

    any thread can call pthread_join for another thread
    

sharing data safely
-------------------

sharing mutable data among multiple threads is inherently unsafe:
    data races

one solution: sequentialize access to shared data structures
    that is, only one thread can access the structure at a time


we can enforce sequential access using a mutex ("lock")


pthread_mutex_t - abstract struct

int pthread_mutex_init(pthread_mutex_t *lock, pthread_mutexattr_t *attrs);

int pthred_mutex_destroy(pthread_mutex_t *lock);



typedef struct {
    int balance;
    pthread_mutex_t lock;
} account_t;


void account_init(account_t *a, int initial)
{
    a->balance = initial;
    pthread_mutex_init(&a->lock, NULL);
}


void account_change(account_t *a, int difference)
{
    pthread_mutex_lock(&a->lock);
    
    // critical section
    a->balance += difference;
    
    pthread_mutex_unlock(&a->lock);
}


lock and unlock ensure* sequential access to balance
    (assuming we don't access the field in some other way)




void account_transfer(account_t *dst, account_t *src, int amount)
{
    account_change(src, -amount);
    account_change(dst, amount);
}


CS 214 / Condition variables
============================

thread-safe queue

-> for safety, ensure only one thread accesses the queue at a time

mutex - abstraction used to coordinate access to a resource
    "locked" - one thread has access (only one!)
    "unlocked" - no thread has access
    
    only the thread that locked the mutex can unlock it
    

what operations should a thread-safe queue provide?
    enqueue
    dequeue
        -> this can't work if the queue is empty
        
    when the queue is empty, we might want dequeue to block until
        another thread enqueues
        
Pthread offers "condition variables"

    mechanism for threads to block until some condition is met
        -> indicated by another thread saying the condition is met


pthread_cond_t


int pthread_cond_init(pthread_cond_t *cv, pthread_condattr_t *attrs);
int pthread_cond_destroy(pthread_cond_t *cv);

int pthread_cond_wait(pthread_cond_t *cv, pthread_mutex_t *lock);
    blocks thread until cv is signaled (temporarily unlocking lock)
    
int pthread_cond_signal(pthread_cond_t *cv);
    wakes one thread waiting for cv

int pthread_cond_broadcast(pthread_cond_t *cv);
    wakes all threads waiting for cv



C1                  P1                      C2
dequeue
    -> wait for
    read_ready

                    enqueue
                        ->signal
                        read_ready
unblocked
                                            dequeue
                                                succeeds
                                                length = 0

    ->wait for
    read_ready

CS 214 / Deadlock, semaphores
=============================

key idea: sequential access to shared mutable resources

key question: what should be sequential?
    how much sequencing do we need?
        making too many things sequential leads to poor performance
        not making enough things sequential leads to data races
            -> incomprehensible behavior


some strategies:
    limit mutual exclusion to individual independent resources
    limit critical sections (i.e., portions of code that require exclusive access)
    
    attempt to divide larger structures
        -- difficult to know when substructures are sufficiently independent


    divide accesses by type
        read/write lock - allows multiple readers, or one writer exclusively


deadlock
--------

recall last week:

    typedef struct {
        int balance;
        pthread_mutex_t lock;
    } account_t;
    
    
    void transfer(account_t *dst, account_t *src, int amount)
    {
        pthread_mutex_lock(&src->lock);
        pthread_mutex_lock(&dst->lock);
        
        src->balance -= amount;
        dst->balance += amount;
        
        pthread_mutex_unlock(&dst->lock);
        pthread_mutex_unlock(&src->lock);
    }
    
    account_t X, Y;
    
    thread A                thread B
    --------                --------
    transfer(Y, X, 1)       transfer(X, Y, 2)
    lock(X->lock)           lock(Y->lock)
    lock(Y->lock)           lock(X->lock)
        blocks                  blocks

each thread is blocking the other from proceeding


four conditions for deadlock

1. mutual exclusion
2. hold-and-wait
    it is possible to block trying to acquire a resource while holding
    another resource
3. no preemption
    if a thread has exclusive access, no other thread can force it to
    release the access
4. circular wait
    e.g., A waits for B, B waits for A


to avoid deadlock, make sure at least one of these conditions will not
apply

e.g., not allowing multiple locks avoids hold-and-wait

always acquire locks in the same order to avoid circularity
    in our example above, we would have no problem if both threads tried
    to lock X first


we can design higher-level abstractions (called monitors) to manage
locks in a way that avoids deadlock



note: deadlock does not require threads
    any two communicating processes can deadlock


barriers
--------

abstraction that creates a "rendezvous" 
    a point where all threads wait until every thread has reached that
    point
    


https://pubs.opengroup.org/onlinepubs/009696899/functions/pthread_barrier_wait.html


pthread_barrier_t

int pthread_barrier_init(pthread_barrier_t *bar,
    pthread_barrierattr_t *attr,
    unsigned count);
        count indicates how many threads must wait at the barrier before
        any of them can advance

int pthread_barrier_destroy(pthread_barrier_t *bar);    

int pthread_barrier_wait(pthread_barrier_t *bar);
        block until the required number of threads have called wait


    for (...) {
    
        // do stuff
        
        pthread_barrier_wait(&bar);
    }
    

semaphore
---------

two operations
    post / increment
    wait / decrement

we can think of a semaphore as an integer,
    perhaps representing the number of available resources
    
post increases the integer by 1
wait decreases the integer by 1, if it is positive
    if the integer is 0, it blocks until the integer becomes positive


a mutex is a semaphore whose maximum value is 1

    mutex       semaphore
    -----       ---------
    init()      init(1)
    locked      1
    unlocked    0
    lock()      wait()
    unlock()    post()

a condition variable can also be a semaphore

    cond.var    semaphore
    --------    ---------
    init()      init(0)
    wait()      wait()
    signal()    post()

    ...almost
    signalling a condition variable when no thread is waiting has no effect
    posting to a semaphore always raises its value

The Little Book of Semaphores


#include <semaphore.h>

sem_t

int sem_init(sem_t *sem, int pshared, unsigned int value);
    initialize semaphore with specified initial value
    pshared is normally 0

int sem_wait(sem_t *sem);
int sem_post(sem_t *sem);

typedef struct {
    int first;
    int last;
    int size
    data_t *data;
    sem_t lock;
    sem_t empty;
    sem_t full;
} queue_t;

void q_init(queue_t *q, int capacity)
{
    q->first = 0;
    q->last = 0;
    q->size = capacity;
    q->data = malloc(sizeof(data_t) * capacity);
    sem_init(&q->lock, 0, 1);   // mutex initially unlocked
    sem_init(&q->empty, 0, capacity);  // all spots are empty
    sem_init(&q->full, 0, 0);  // no spots are full
}


void q_enqueue(queue_t *q, data_t item)
{
    sem_wait(&q->empty);
    
    sem_wait(&q->lock);
    
    q->data[q->last] = item;
    q->last++;
    if (q->last == q->size) q->last = 0;
    
    sem_post(&q->lock);
    
    sem_post(&q->full);

}

void q_dequeue(queue_t *q, data_t *dst)
{
    sem_wait(&q->full);
    
    sem_wait(&q->lock);
    
    *dst = q->data[q->first];
    q->first++;
    if (q->first == q->size) q->first = 0;
    
    sem_post(&q->lock);
    
    sem_post(&q->empty);
}



major differences with semaphores

    in general, any thread can post to any semaphore
        mutexes have more restrictive rules, so it's easier to see when
        they are being misused

    more possible states
        e.g., we can count the number of available resources

    semaphores can simulate condition variables, but work is needed
        to handle broadcast or to "lose" signals when no thread is waiting

posix-specific differences

    sem_post and sem_wait are "safe" to use in signal handlers
    
    semaphores can be shared among multiple processes
        sem_open() associates a sem_t object with a semaphore file
            in the file system (accessible by multiple processes)


Possible tools:
    thread sanitizer   -fsanitize=threads
        can't be used with address sanitizer

CS 214 / Multithreading examples
=================================

Reminder: late policy is 10 points per day (rounded up)
    but will not reduce score below 60

Final exam date will be announced soon
    will be given on-line via Canvas
    24-hour window
    format: primarily multiple choice


there will be no project IV
    we will repurpose it as in-class examples



exercise: read/write lock
-------------------------

allows any number of threads to have read access concurrently
or one thread has write access

four operations
    read_lock:
        obtains read access
        blocks if any thread has write access
    read_unlock
    write_lock
        obtains write access
        blocks if any thread has read or write access
    write_unlock
    
    init
    destroy


information you will probably need
- how many threads have read access
- how many threads are waiting for write access
- whether the lock is currently open for reading or writing or neither

- use mutex/condition variable or semaphores within the lock functions



starvation
----------

occurs when a thread is waiting for a resource, but other threads prevent
it from acquiring the resource


for example, multiple threads can be getting read locks in overlapping
finite time periods. a thread waiting for write access may wait
indefinitely

    one possible solution: enforce turn-taking
        e.g., don't allow threads to get read access if a thread is
            waiting to get write access



livelock
--------

occurs when two or more tasks make state changes that undo the
    work of the other tasks
    -> the tasks end up spending all their time undoing and redoing
        the same state changes, and never actually advancing to do
        something productive




    thread A            thread B
    --------            --------
    while X != 1        while X != 0
        X = 1               X = 0
    do stuff            do stuff
    


another queue example
---------------------

scenario: multi-threaded recursive directory traversal
    want to divide work among N threads, for some fixed N
    
idea:
    pool (list) of directories to be traversed
    each thread will:
        1. obtain directory path from pool
        2. traverse directory
        3. add any subdirectories to the pool
        4. repeat until "finished"


    advantages of this approach:
        finite number of directories open at once
        work automatically distributes among threads
        
questions:
    how do we know when we're done?
        - pool is empty & and all the threads are waiting

    can we use a bounded queue?
        - we risk deadlock if the queue is full and all threads are
            trying to enqueue


    typedef struct {
        int arraysize;
        int itemcount;
        char **paths;   // array of strings
        int active;     // count of active threads
        pthread_mutex_t lock;
        pthread_cond_t read_ready;
    } pool_t;
    
    void pool_init(pool_t *p, int threads, int capacity)
    {
        ...
        p->active = threads;
        ...
    }
    
    void pool_add(pool_t *p, char *path)
    {
        pthread_mutex_lock(&p->lock);
        
        // check for free space
        if (p->itemcount == p->arraysize) {
            p->arraysize *= 2;
            p->paths = realloc(p->paths, p->arraysize * sizeof(char *));
        }
        
        p->paths[p->itemcount] = path;
        p->itemcount++;
        
        pthread_cond_signal(&p->read_ready);
        
        pthread_mutex_unlock(&p->lock);
    }
    
    // return 1 for success, 0 for failure
    int pool_remove(pool_t *p, char **dst)
    {
        pthread_mutex_lock(&p->lock);
        
        if (p->itemcount == 0) {
            p->active--;
            
            // check whether we were the last active thread
            if (p->active == 0) {
                pthread_cond_broadcast(&p->read_ready);
                pthread_mutex_unlock(&p->lock);
                return 0;
            }
            
            do {
                pthread_cond_wait(&p->read_ready, &p->lock);
                
                // check whether any threads are still running
                if (p->active == 0 && p->itemcount == 0) {
                    pthread_mutex_unlock(&p->lock);
                    return 0;
                }
            } while (p->itemcount == 0);
            
            
            p->active++;
        }
        
        p->itemcount--;
        *dst = p->paths[p->itemcount];
        
        pthread_mutex_unlock(&p->lock);
        
        return 1;
    
    }
    
    







CS 214 / Network communication
==============================

what do we mean by network communication?
    - sending messages from one computer to another
    - more precisely: from a process on one computer to a process
        on a different computer


What is needed for network communication?
    protocol: what sorts of messages can we send?
        how are they expressed?
        when are they sent and by whom?
    
    addressing: how do we indicate the participants?



layers from the ground up:

how do I communicate between two computers?

one answer: connect a wire between them

two or more connected devices are called a "link"

to add more than two hosts, we can add special devices
    hub - in Ethernet, a device with a certain number of ports (e.g., 4)
        we run a wire from each host to a port on the hub
        the hub forwards any messages it receives to every other host
    
    -> in Ethernet, every message frame includes a destination address
        every Ethernet device has a unique address (MAC)
        when a device receives a message for a different MAC, it ignores
            the message
            
    because hubs simply forward frames, they are very simple
        -> fast and inexpensive
    but forwarding every frame to every participant uses a lot of
        network resources
    
    
    switch - similar to a hub, but it associates MACs with ports
        messages are only forwarded to the port associated with the
            destination
        
        because the switch has to examine messages and keep track of
            MACs, it is slower and more expensive than a hub

typically, a link involves devices controlled by a single organization
-> not especially secure
-> every device can talk to any other device
-> little privacy

Ethernet also describes
    how are messages sent?
        large messages are broken into smaller parts
        each part is made into a "frame"
        the frame also includes the destination address
    
    how is network time divided?
        in the event two devices try to send at the same time, both
        will wait a random amount of time and retransmit
        -> this works well in practice!




internetworking - communication between devices on different networks

idea: our link contains one or more devices called "routers" or
    "border routers"
    
    a router connects two networks
    
Internet Protocol (IP)
    hosts are identified by IP address
        in IPv4 - 32-bit integer
            commonly written in "dotted quad"
            e.g., 127.0.0.1
        
        in IPv6 - 128-bit integer
            commonly written as groups of four hex digits separated by
            colons

    messages are broken into "packets"
        each packet indicates its source and destination IP addresses
        packets are sent separately across the network
        routers receiving a packet will transmit it to a peer hopefully
            getting it closer to its destination
            
        IP is a "best effort" protocol
            packets may be lost
            packets may be received out of order

    each router has a routing table
        -> given an IP address, which outgoing port should this packet
            be sent to?

    to keep the routing table simple, addresses are grouped into "subnets"
    typically, addresses with a similar prefix are part of the same
        subnet, and so one entry in the table can handle all of them
    
    early internet used three "classes" of subnets
        class A uses 8-bit prefix
        class B uses 16-bit prefix
        class C uses 24-bit prefix
        
    modern IPv4 uses "classless" routing where subnet prefixes can be any
        length
        
        often indicated with a slash and a number
        208.13.128.0/9  - indicates a subnet with a 9-bit prefix

    routers have their own protocols to send updated routing information


CS 214 / Sockets
================

Network stack
    link layer - communication between machines on the same network
        Ethernet - communicates in discrete messages (frames)
    
    Internet layer (IP) - communication between machines on the Internet
        packet forwarding, best-effort
            messages are broken into individual packets, each sent
            separately
            messages can be lost, or arrive out of order
        
        IP packets are roughly 20 - 65,000 bytes
            packets that are too large for the underlying transport
            are "fragmented" and reassembled at the recipient
            1500 bytes is a common size
    
        endpoints are identified by IP address
            - identifies a network interface (usually 1 per machine)
    
    Transport layer
        UDP (User Datagram Protocol)
            send individual messages from one service to another
            endpoints identified by IP address and port number

            best effort, datagram protocol
            non-connection oriented
            
        TCP (transmission control protocol)
            read and write byte streams sent between two services
            endpoints identified by IP address and port number
            
            connection oriented
            TCP itself makes sure that bytes are received in order
            TCP divides the outgoing byte stream into "segments"
                (each segment is sent in a single packet)
                
            from an application standpoint, most of the work is done
            by the OS
            

sockets
-------

a set of functions used to establish network communication
part of POSIX

fundamental type: the socket
    this is a file descriptor that refers to a network service
    
functions attempt to be as general as possible
    does not assume we are using a particular network
    does not assume we are working at a particular level


int socket(int domain, int type, int protocol);

    domain - what sort of network will we be using (AF_INET)
    type - what sort of socket are we creating
        SOCK_STREAM  - communication via streams (e.g. TCP)
        SOCK_DGRAM   - communication via datagrams (e.g., UDP)
        various others used by other network types
    
    protocol - used to distinguish between multiple transports of the 
        same type (typically 0)

    returns a file descriptor on success
    returns -1 on failure
    
    this creates an abstract socket, but does not configure it
    
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);

    for streaming sockets, establish a connection with a service on
    a remote host
    
    sockfd  - file descriptor returned from socket()
    addr    - address of the remote service
    addrlen - length of the addr struct
    
    note: addresses are usually network-specific structures
        we cast the pointer to struct sockaddr * and provide the size
        
        usually we don't create this struct ourselves


domain name service (DNS)
-------------------------

DNS a distributed hierarchical database that stores information about
    "domains"
    
    domains are identified by words separated by periods
    
        rutgers.edu
        google.com
        amazon.co.uk
        cs.rutgers.edu
        www.cs.rutgers.edu
        
        subdomains add additional words to the front of the name
        
    each domain is controlled by some organization, which can establish
        subdomains with their own owners
        
    
    each domain can have several kinds of information
        e.g., who controls the domain & how to reach them
        
        A - associates an IPv4 address with this domain
        AAAA - associates an IPv6 address with this domain
        MX - indicates the machine used for mail handling
        
for many protocols, we look up the IP address for a domain and use that
to connect (or send datagrams)


data is stored hierarchically, similar to directories in the file system

    edu says where to find rutgers.edu
    rutgers.edu says where to find cs.rutgers.edu
    cs.rutgers.edu says where to find wax.cs.rutgers.edu
    
typically, you will have a local DNS server that caches results from
past DNS queries

the Unix commands host and dig perform DNS queries and print the results


typically, your local internet configuration will specify a DNS server
used for queries


using DNS to get addresses
--------------------------

the old way: gethostbyname()

the better way:

int getaddrinfo(
    const char *node,             // e.g., domain name
    const char *service,          // e.g., service name or port number
    const struct addrinfo *hints, // used to narrow down results
    struct addrinfo **res);       // will point to first entry in a linked
                                  // list of answers
             
             
    returns 0 on success
    an error code on failure
        (not compatible with errno, perror(), etc.)
        (use gai_strerror() to get a description of the error)

struct addrinfo {
   int              ai_flags;
   int              ai_family;    // domain argument to socket()
   int              ai_socktype;  // type argument to socket()
   int              ai_protocol;  // protocol argument to socket()
   socklen_t        ai_addrlen;
   struct sockaddr *ai_addr;      // addr argument to connect()
   char            *ai_canonname;
   struct addrinfo *ai_next;
};


see network.c for examples of using getaddrinfo() with socket() and connect()


usual pattern for clients:
    use getaddrinfo() to get a linked list of address information records
    use these with socket() and connect() to establish a connection
    
client-server pattern:
    client creates connections (active)
    server waits for clients to request connections (passive)
    
establishing a listening socket requires three functions

int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);

    tells network system to associate our socket with a specific port
    on the local host
    
    sockfd - obtained from socket()
    addr - identifies the port (recommended: obtain from getaddrinfo())
    
    returns 0 on success, -1 on failure (sets errno)
    
int listen(int sockfd, int backlog);

    tells network system that we want to wait for incoming connection
    requests
    
    sockfd - obtained from socket()
    backlog - determines size of connection request queue
    
    returns 0 on success, -1 on failure (sets errno)
    

int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);

    obtain file descriptor for an incoming connection request
    (block until one arrives, if none have arrived yet)
    
    sockfd - listening socket
    addr - address of remote host will be written here
            (use NULL if we don't care)
            
    returns a new streaming socket specific to this connection
    returns -1 on failure (sets errno)
    
each time we accept a connection request, we get a new socket





    





CS 214 / Application protocol
=============================

Recap: basic sockets interface

Optional: getaddrinfo()
    used to loop up domain names and port numbers
    populates the struct sockaddr used with bind() and connect()
    simplifies writing programs that work with IPv4 and IPv6
    
Opening a connection to an existing listener over TCP:

    socket()
        - establishes socket abstraction
        - specifies address domain, socket type, and "protocol"
    connect()
        - establishes connection to remote host
    
    write()  - send data to remote host
    read()   - receive data from remote host
    
    close() - closes both sides of the connection
    shutdown() - used to close one side of the connection
    

Creating a listener to wait for connection requests (over TCP):

    note: use AI_PASSIVE flag when calling getaddrinfo()
        use NULL for the node name (indicates local host)

    socket()
    bind()
        - associates our socket with a port number on our host
    listen()
        - tells network interface we want to receive connection requests
    
    accept()
        - receive incoming connection request (block if none yet)
        - returns a new socket associated with the incoming connection
        
    read()
    write()
        - used to communicate with socket obtained from accept()
    

TCP connections
    incoming TCP packets indicate which connection they are part of using
        - local host:port
        - remote host:port
        
        
example:
    three machines: A (listener), B, C
    A binds its socket to port 10000
    B and C coincidentally also use 10000
    
        the A-B connection will have A:10000, B:10000
        the A-C connection will have A:10000, C:10000
        
    two machines: A (listener), B
    A binds its socket to 10000
    B opens two connections to A:10000
        these must have different port numbers on B
        e.g., 100, 101
    
        connection 1 is A:10000, B:100
        connection 2 is A:10000, B:101
        
listeners must bind() in order for other hosts to know how to establish
    the connection
    
connectors don't need to bind(), because it does not matter which port  
    they use, as long as it is not already in use
    
note: there must be some agreement on how clients can learn the port
number used by the server
    - this is usually specified by the protocol
    
fixed or "well known" port numbers are assigned by IANA
    (there is a range of port numbers that will never be assigned)
    

server structure
----------------

"one at a time"

    repeat forever:
        accept incoming connection
        communicate with peer
        close connection
        
    easy to write
    can only deal with one client at a time
    

one connection per process

    repeat forever:
        accept incoming connection
        fork child process
            in child: deal with connection

    allows multiple concurrent connections
    provides some insulation (one connection handler cannot crash server)
    cumbersome communication between parent and children
    
    problem: how to deal with zombies
        - install handler for SIGCHLD 
            handler uses waitpid() to clean up the specific zombie
            
        - set SIGCHLD to SIG_IGN
            prevents child processes from becoming zombies
            (they just disappear when they terminate)
            

one connection per thread

    repeat forever:
        accept incoming connection
        create new thread to handle connection
        detach thread
        
    allows multiple concurrent connections
    easily shared data among all connection handler threads
    minimal protection from infinite loops or crashes
    
    we might want to address signal handling
        signals sent to a multithreaded program will be handled
        by an undetermined thread
        - we can control this by setting signal masks per thread
        - e.g., SIGINT or SIGHUP being handled by primary thread
        
multiplexing

    fewer threads than connections
    problem: we don't know what events will happen next
        should we call accept() or read() on a particular socket?
        how do we avoid waiting unnecessarily
        
    solution: select() or poll() allow us to block on multiple
        file descriptors at once and wait until any of them are ready
        
    lower latency than using multiple threads
    more complicated to write
    makes it easy to specify timeouts
    

    
    



CS 214 / Application example
============================

Schedule:
April 29: review for final exam
Final Exam: Monday, May 6
    On-line via Canvas
    Available for 24 hours
    If you have two other exams on May 6, contact me
        put [CS214] Exam Conflict as your subject


The Ghost of Project IV
-----------------------

on-line video game server for rock-paper-scissors

Application
Presentation
Session

Transport  -- these already exist (we are using TCP/IP)
Network
Data Link
Physical



What roles are there?
    Server - waits for connection requests
        - associates players with game instances
        - determines who wins/loses
    Client - initiates connections
        - represents a player
        

one connection per client per game session

    a game session may contain multiple RPS rounds
    game session ends when one client decides to quit
    

what kinds of messages are needed?

    server should say when to move
    clients should say what moves they are making
    server should say who won/lost/drew
    clients should say whether they want to continue
    
    client initiates communication 
        - can be minimal, or contain some information
            - client name, preferred game variant
            - protocol version
    server acknowledges this
        - indicates acceptable info from client
        
        
    Client      Server
        -- PLAY ->
        <- WAIT --
        
        <- BEGIN --
        -- MOVE -->
        <- RESULT --
        
        -- QUIT/CONTINUE ->
    
    need to decide how to handle inappropriate messages
        - messages sent by the wrong participant
        - messages sent at the wrong time
    
    possible responses:
        - shut down connection
        - send error message and shut down connection
        - send error message and try to recover
        

Presentation:
    for today, extremely simple:
    all messages are one byte

    (useful for a proof-of-concept, rough draft protocol)
    
    
server design
-------------

How can we test our server?

- for testing, we can build a simple client that doesn't assume
  the server is correct
  

how should the server be structured?

    - one thread that handles everything
    - one thread per connection (=> two threads per game)
    - one thread per game (=> two connections per game thread)
    

idea: central thread repeatedly calls accept()
    once two connections have started, it spawns a thread to manage 
        the game session





        
    


    

CS 214 / Protocols
==================

Recap:
    in defining our protocol, we are specifying
    session layer
        - who establishes connections
        - when are they opened
        - when are they closed
        
    presentation layer
        - how messages are formatted
        - determining where one message ends and the next begins
    
    application layer
        - what messages can be sent
        - when and from whom messages are appropriate

rps protocol

    Client          Server
    initiate
    
        -- PLAY ->
        <- WAIT --
        
        <- BEGIN --
        -- MOVE ->
        <- RESULT --
        -- QUIT/CONTINUE ->


        
        
last time, we chose a minimal presentation:
    all messages are one byte
    

we skipped most discussion of error conditions

things that can go wrong
    - connection closes unexpectedly
    - garbage data / improperly formatted message
    - inappropriate message
    
there is no strategy for these that is appropriate in all situations


    - for rpsd, we can just close the connection and cancel the game
        rpsd = rock-paper-scissors daemon
            daemon - traditional Unix term for a server


once we allow multi-byte messages, we also have this problem
    - message arrives, but is incomplete
    
    
depending on our design, we may want more control over when threads
block waiting for input
    - if we don't care, we can just call read() until we get the rest
      of the message
      
    - the protocol may specify some limits, e.g. a message must arrive
        within 500 ms
        
        
consider code using poll() or select() to wait for incoming data
on multiple sockets
    - if data arrives on a socket, but it isn't a complete message,
        how should we handle it?
        - call read() again and block until more data arrives?
            -> no longer able to look for data on other sockets
        - stuff partial message in a buffer and call poll() again
            -> responsive to input on all sockets, more complicated


if we use one thread per connection, we avoid the need for poll()
    threads can just block on read()
    but we need a way to force threads to wake up
        -> e.g., we can send a signal to the thread
                pthread_kill()
                signals like SIGUSR1 and SIGUSR2 are unlikely to be
                sent by other processes



multi-byte messages
-------------------

allowing longer messages greatly increases the amount of data we can send

    e.g., messages can have parameters
        e.g., PLAY can include a protocol version, user names, etc.
        
    messages may be variable-length
    
we need a way to tell whether we have a complete message

    - we should not assume that a single call to read() will return
        a single message
        
        (it is common in testing to receive a single message at a time,
        which can lead to a false sense of security)

-> message format should make it obvious when a sequence of bytes
    encodes a complete message
    
approaches:
    fixed-length messages
    delimiters
        some byte sequence that indicates the end of a message
        
    explicit length indicator
        sequence towards the start of the message indicating how many
        additional bytes are coming
        
    delimiters and explicit length indicator
        additional security
        
        
        
example: PLAY mesage with variable-length user name

delimiter
    PUser Name|
    
    P|User Name||

message-specific delimiter
    P~~User Name~~
    
explicit length field
    P|9|User Name

length field + delimiter
    P|11|User Name||
    
we can use one length field even with multiple variable-length fields
    Z|15|Hello|Goodbye||


choice of delimiters may depend on what sort of data we are sending
    e.g., | isn't a good choice if our data will contain Unix commands
    
    we can get around reserved characters using escape sequences,
    but now we have to encode and decode the message fields



Revised RPS protocol

    PLAY <user name>
        P|<user name>||
        
    BEGIN <opponent name>
        B|<name>||
        
    MOVE
        M|<move name>||
        
    RESULT
        R|<result>|<move name>||
        
    QUIT
        Q
    CONTINUE
        C
    WAIT
        W
        
        
for responsiveness, separate recv_msg() into two functions
    refresh_handle()
        - calls read() and adds bytes to the handle's buffer
        - idea: use poll() to tell when data has arrived, then use
            refresh_handle() to receive the data
    
    
    parse_msg()
        - reads data that has already arrived (in the handle's buffer)
        - returns
             1 - if a complete message was found
             0 - if an incomplete message has arrived
            -1 - if the data is not a message
            
this design allows us to watch for incoming data on multiple sockets
using poll() while controlling when we block
    - e.g., we only block in poll()
    - we can check whether a complete message has arrived without blocking


        
        




CS 214 / Review
===============

Final Exam: Monday, May 6
	On-line via Canvas
	Available for 24 hours
	Exam itself will be approx. 1.5 hours total

C programming
-------------

C syntax

types
    - integer types 
    - floating point
    - enums
    - structs
    - unions
    - arrays
    - pointers
    
C pointers
    address of data (run-time)
    type (compile-time)

    pointer types are used to generate appropriate code, but are
    forgotten after compilation
        given a pointer, there is no way to query what sort of data
        it refers to
        
    "void" pointers have no type information
        - they must be cast to a specific pointer type to be used
        - or we can use generic operations such as memcpy() 
            - but only if we know the size of the data

        - to use properly, we need to know (as programmers) what sort
          of data we are using, even if it is not expressed in the types

memory allocation/deallocation
    malloc() / calloc() / realloc() - reserve space on the heap
        the run-time system maintains some sort of data structure that
        tracks which portions of the heap are allocated or free
    
    free() - deallocates a previously allocated heap object

object vs data

    object - location in memory that can hold data
    value  - actual bytes stored in an object at some point in time
    
    an address identifies an object
    
    a pointer variable has an object that stores the address of
        another object
        
        &p  - address of the pointer variable itself
        p   - value of the pointer, address of the object it points to
        *p  - value of the object it points to
        
        int I[2];
        I[0] = 10;
        I[1] = 20;
        int * p;
        p = &I[0];

        
        ++(*p)  => 11, changes I[0] to 11
        *(++p)  => 20, changes p to &I[1]
        (*p)++  => 10, changes I[0] to 11
        *(p++)  => 10, changes p to &I[1]


Macros/Preprocessor

    the preprocessor changes C source code into C source code
    
    #define SECRET 20
    
    #define MEAN(X, Y)  ((X)/2 + (Y)/2)

    
        MEAN(a, b)   => ((a)/2 + (b)/2)
        
        MEAN(a + b, c)  => ((a+b)/2 + (c)/2)
        1/MEAN(a, b)    => 1/((a)/2 + (b)/2)


    #define FOO(X)  ((X)++/2)
    
    
        FOO(bar)   => ((bar)++/2)


Posix File IO
-------------

C (and Posix) model files as a stream of bytes
=> actually, many things can be treated as streams of bytes
    Posix uses the file interface to deal with many of these
    
        files on disk (open())
            - can include many "non-file" file-like things
                FIFOs, devices, terminals
        pipes (pipe())
        terminals
        sockets (socket(), accept())

    different streams offer different operations
        read()
        write()
        lseek()
     
streams are identified by "file descriptors"
    -> numbers that index into a table of open streams

Posix file operations are "unbuffered"
    we provide our own buffer, and get data as soon as we ask for it
    
    char buf[200];
    read(fd, buf, 200);  <- obtain up to 200 bytes
    
    read() and write() return the number of bytes read/written
        -> why?
        


C file operations are "buffered"
    the FILE struct includes a buffer of data from the stream
    calls to fscanf() read from the buffer, and call read() internally to
        refresh it
    
    calls to fprintf() write to the buffer, and call write() internally to
        flush it



File system
-----------

Files are identified by i-node number (and device number)
    
    every file has exactly 1 i-node and zero or more data nodes
    
    i-node stores data about the file
        size
        who owns it
        what permissions it has
        where its data are stored
        
            -> direct and single/double/triple indirect references
            allows for very large files
            keeps i-nodes with a small, fixed size
            fast access to all parts of the file

    => not included: file name
    
directory hierarchy

    a directory file maps names to i-nodes
    
    starting from the root directory, we can define a path to a file
    
        /directory/subdirectory/subsubdirectory/name
        
        "directory" in /
        "subdirectory" in /directory
        "subsubdirectory" in /directory/subdirectory
        "name" in /directory/subdirectory/subsubdirectory

    each directory entry that references an i-node is a "link"
    the number of links to a file is the number of entries it has
    
    files can be linked any number of times
    
    every directory is linked in at least two places
        -> its parent (via its name)
        -> itself (via .)
        
        -> from each of its subdirectories (via ..)


Processes
---------

a process is an abstraction that executes a program
    -> a virtual memory (containing instructions)
    -> current processor state (program counter, registers, etc.)

    "program plus state"


processes are identified by process id (PID)

to create a new process, call fork()
    - duplicates current process
    - new process (child) starts with same state as parent
        -> is about to return from the call to fork()
        -> all data in memory is copied
        -> all open files are now open in the child (as well as in the parent)

    "fork returns twice"
    
    
    returns 0 in the child, returns PID of child in the parent
    
after calling fork(), parent should (eventually) call wait()
    -> learn that child has terminated
    -> obtain exit status of child


execv(), execl()
    - change the current program
    - start executing a new program; abandon the current program
    - memory is effectively cleared
    - retain PID
    - open files (mostly) remain open
    
    "exec does not return"
    
common pattern

    if (fork() == 0) {
        // set up some stuff with files
        execl(...)
    }
    wait()


Signals
-------

mechanism to interrupt a process
-> asynchronous communication with a process

signal types are identified by number (usually written as constants)
    SIGINT, SIGTERM, SIGKILL, SIGCHLD, etc.
    
can be triggered by errors or sent by other processes

a process sets a "disposition" for each signal type
one of:
    terminate
    ignore
    call a handler function
    stop
    continue


handler functions can stop the process (by calling exit()) or
resume executing from the point where the signal was received (by returning)

    -> it is only safe to resume from non-error signals


    signal handlers can only call a subset of "safe" functions


we can decide whether system calls resume or stop if we get a signal


signal mask
    - set of signals that are "blocked"
    
    blocked signals are not delivered, but also are not discarded
    if the signal is later unblocked, any pending signals will be delivered


Multithreading
--------------

allows us the benefits of multitasking within a single process
-> single shared memory


benefits: easier communication
drawbacks: more need for coordination

data race
    multiple threads access a piece of data and at least one access is
    a write
        (without coordination)
    
C programs containing data races are undefined

avoid data races by coordinating

e.g., use mutual exclusion to enforce sequential access
    -> no uncoordinated access means no data races
    -> still can have nondeterministic behavior
    

pthread library

    pthread_create()
    pthread_join()
    
    pthread_mutex_t  - used to coordinate exclusive access
    pthread_cond_t   - allows thread to block until another thread says
                        it can continue

    pthread_barrier_t
    sem_t


atomic instructions

    to implement mutex, we need a way to perform multiple memory operations 
    such that no other thread/CPU can access it "in between"
    
    test-and-set   - in one step, check whether an object has a certain
        value and set it to something
    compare-and-swap
    
    
    var M;
    
    if (test-and-set(M, 1) == 0) {
        // we know no other thread saw M was 0 before we could set it to 1
    }
    
    => without hardware support for atomic instructions, no coordination
        between threads is possible

deadlock: 4-necessary conditions
    mutual exclusion
    hold and wait
    no preemption
    circular wait


Networking
----------

sending messages from one process on one device to another process on
    a different device
    -> these devices may not be directly connected to each other
    
"link layer" - communication between directly connected devices
"network layer" - communication between devices on the same network
    (e.g., the Internet)
"transport layer" - communication between specific processes
"application layer" - the actual messages


sockets interface - used to establish communication by applications

    socket - identified by file descriptor
        abstract interface that may be connected to the network
        
    socket() - creates new (unconnected) socket
    
    connect() - connects a socket to a specified remote host/service
    
    bind() - connects a socket to a service on the local host
    listen() - indicates we want to accept incoming connection request
    accept() - waits for a connection request, returns a new socket
        handling the connection


there are many kinds of socket
sockets created with SOCK_STREAM will present a stream interface
    that can be used with read() and write()


    transport will ensure that bytes we send are received and that
    the bytes we receive are in the proper order and not missing anything

points to consider:
    avoiding blocking
    know where your message boundaries are
    
    know which party establishes the connection
    know how messages are encoded
    
OSI model
    physical
    data link
    network
    transport
    session
    presentation
    application



