CS 214 / Introduction, C
========================

Prof. David Menendez <davemm@cs.rutgers.edu>
    Please put [CS214] in your subject line
    Use the discussions tab on Canvas for general questions

    Office: Hill 448

Systems Programming
    Sections 05-08
    
    Run-time system 
    Operating system
    
C Programming Language
Unix-style operating systems (linux, Posix)
    - files
    - file system
    - multitasking, process control
    - multithreading (pthread)
    - network communication (sockets)


Project-oriented class
    Three or four programming assignments
        Two-person assignments
        Why?
        - most of you will need to work with others in the future
        - opportunity to work with others
        
        tips
        - communicate
        - determine clear goals and responsibilities

Reference compiler is GCC 11.4 - installed on iLab
    GCC = GNU Compiler Collection
    GNU = GNU's Not Unix


Why C?
------

C is a relatively simple language
- gives good visibility into the low-level aspects of the computer
- designed to run (and be compiled) on low-powered hardware


C vs Java
- similar syntax
- similar orientation

Java is an interpreted language
    java source code --javac--> "bytecode" --java--> execution
    MyClass.java --> MyClass.class


C is a compiled language
    myprogram.c --gcc--> myprogram

    compiler translates source code to machine code
        source code - text readable by humans
        machine code - binary format understood by the CPU


    "compile time" - when the compiler translates your code
        compile time errors - problems with your code that prevent
            it from being compiled (syntax errors, type errors, missing names)
        "static analysis" - determines properties that are true for
            all possible executions
    
    "run time" - when your compiled code is executing
        run-time errors - problems with your code that happen while it
            is executing
        "dynamic analysis" - determines properties that are true for
            a specific execution
            
    stages of compilation
        preprocessing - source to source translation
        compilation - translates source code to machine code
            "object file" is machine code that doesn't contain all definitions
        linking - combines multiple object files into an executable

    why separate compiling and linking?
        re-compiling large programs takes time
        splitting our source into multiple files means we only need
            to recompile the files that change


gcc myprogram.c
    compiles and links and creates an executable called "a.out"

gcc myprogram.c -o myprogram
    compiles and links and creates an executable called "myprogram"
    
gcc -c myprogram.c
    compiles program and creates an object file "myprogram.o"
    
gcc myprogram.o -o myprogram
    links myprogram.o (to the standard library) and creates executable "myprogram"

gcc myprogram.o mylibrary.o mydatastructure.o -o prog
    links multiple object files (and standard library) and
    creates executable "prog"
    
-Wall
-fsanitize=address


Java has a hierarchical name space
    classes have names like java.sun.foo.bar.MyClass
    methods are specific to a class

C has a flat name space
    all functions and global variables must have unique names
    can be difficult to coordinate large projects
        -- not an issue for us


Java has classes and methods
C has functions
    functions are just named bits of code you can call (with parameters)

implications:
    no implicit parameters (this)
    no polymorphism/overloading

Types
-----

C has a small set of built-in types
    integers (int)
        unsigned/signed  - are negative numbers allowed?
        short/long/unspecified - how many bits are used?
            - C does not specify sizes for int/short int/long int
            - short int is at least 2 bytes
            - long int is bigger than short int
            - int is at least as big as short int
            - long int is at least as big as int
            sizeof(int)
        
    char - "characters"
        these are just integers
        ASCII assigns numbers to popular symbols
            'A' == 65
        chars can be signed or unsigned
        
    floating point
        float, double
        C does not require IEEE floating point, but all modern hardware
            uses it
        
        always use double, unless you are tight on memory
    
    arrays - arrays in C are a state of mind
        an array of ints is just a bunch of ints adjacent in memory
    
        arrays do not track their length!
            if you don't know, you should have kept track of it
        
        
        






    
    

CS 214 / C Intro/Review
=======================

Please look for an announcement regarding recitation

types (continued)
-----------------

C's type system is pretty minimal
    - types are primarily used by the compiler for code generation
        how much space to allocate for a variable
        what instructions to use when manipulating data
            e.g., does < turn into signed/unsigned integer comparison
                or floating point comparison?
    - occasionally, the compiler will detect and report type errors
        certain types do not have automatic conversion (e.g., ints and
            arrays)
        however, the compiler will automatically convert number types
        
        int x = 5;
        float y = x / 2;
            // does integer division, then promotes the result to a float
        float z = x / 2.0;
            // promotes the value of x to a float and does floating-point
            // division
        
        // y == 2.0, z == 2.5
        
explicit casts
    we can explicitly cast a value from one type to another
    (desired_type)
    
        (float) x / 2;
            // casts x's value to a float, then performs FP division

more types are numbers than you might think
    char x = 'A';
    int y = 'A';  // also ok!


enumerated types
----------------

used to create a type with a small, discrete set of values

    enum direction { north, east, south, west };
    enum color { red, green, blue, yellow, gray };
    enum bgtype { fill, transparent, striped };
    
enum direction heading = north;

    "enum direction" is the type

switch (heading) {
    case north:
        ...
    case east:
        ...
    ...
}

like characters, enums are just fancy integers
each "enumerator" is given an integer value

we can treat enums like integers in ways that may or may not make sense

    enum log_level { CRITICAL, FATAL, ERROR, WARNING, NOTE };
    
    enum log_level msglevel = ...
    
    if (msglevel <= ERROR) {
        ...
    }
    
technically, anything you can do with enum you could do with int and
some declared constants
-> using enums can provide some hints to people reading your code



arrays
------

contiguous sequences of values of some type

when we declare an array variable, we must indicate its dimension

    int a[5];
    int b[] = {1, 2, 3, 4, 5};
        // implicitly declared dimension from initializer
    int c[20] = {1,2,3,4,5};
    
    int a, b, c[4];
        declares a and b as int, and c as array of 4 ints
        
array indexing in C is not bounds checked
    arrays do not store their dimension at run-time

multidimensional arrays are arrays of arrays

    double matrix[R][C];
        matrix is an array of R elements
        each of which is an array of C doubles
    
    in memory, this is indistinguishable from an array of R*C doubles

    writing matrix[1] gets me the second row of the matrix
    writing matrix[1][1] gets me the second element of the second row
    

one special kind of array
    C does not have a string type
    C represents strings using character arrays containing a terminator
        terminator is a char with numeric value 0
            0, '\0' (in ASCII, this is called NUL)
            do not confuse this with '0'
    by definition, a string ends with the terminator
        (or is the characters preceding the terminator, depending on your view)


in most contexts, a string literal will refer to a character array
in the static, read-only part of your program's memory

    char *p = "hello";
    
    p[0] = 'H';  // probably crashes your program
    
    char s[] = "hello";
        initializes s to contain these characters
        equivalent to:
    char s[] = {'h', 'e', 'l', 'l', 'o', '\0' };
    
    s will be in writable memory, so I can change its contents later


    char t[] = {'h', 'e', 'l', 'l', 'o'};
        t will contain these 5 characters, but not a string
        
    char name[128] = "Joe Someone";
    
C uses terminators because strings have different lengths
we may want to store different strings in a particular array
the terminator tells us how long a particular string is

    the length of the array is fixed
    the length of the string in the array is variable


structs
-------

a way to bundle values of different types
    the number and types of the values is fixed
    values are referred to by name ("fields")
    
struct point {
    double x;
    double y;
};

    // declares a type "struct point"
    // a struct point has two fields: x and y

struct point p;
p.x = 1;
p.y = 2.5;

    // we can initialize a struct using the curly braces
    // fields are given in the same order as the struct declaration
struct point p = { 1, 2.5 };

int is_northwest(struct point p)
{
    return (p.x > 0 && p.y > 0);
}

void do_nothing(struct point p)
{
    p.x += 25;
}


struct point move(struct point p)
{
    p.x += 25;
    return p;
}


note: we don't usually pass structs to functions or return them


struct triangle {
    struct point vertices[3];
    enum color bgfill;
}


struct triangle drawlist[200];

we can mix and chain array indexing and field accesses

    drawlist[20].vertices[1].x = 0;


union
-----

allows us to make a type that stores values from a small set of types

union intorfloat {
    int i;
    float f;
};

union intorfloat x;
    // x can contain an int or a float, but not both


x.i = 5;
x.f = 1.0; // overwrites the 5 with 1.0

there is no way to query x to find which type of value it contains

unions are only safe to use in a context where it is known what type
    they contain, or that information is kept elsewhere


x.i = 5;
printf("%f\n", x.f);  // undefined!


typedef
-------

allows us to give a new name to an existing type

typedef int color;
    // "color" is a new name for "int"

color background;
color foreground;

this is a new name, not a new type
the compiler is happy to mix code using int and color

typedef struct point point;
    // "point" is a new (shorter) name for "struct point"
    
typedef double vector[3];

    vector p;
    double p[3];  // the same



pointers
--------

all data in C is stored in memory
all memory locations have an address
a pointer is a value that represents an address/the location of some data

implications:
    all variables have an address
        &x evaluates to the address of x, not its value
    all struct fields and array elements have addresses
        &a[4]
        &p.x
        &drawlist[20].vertices[1].x
    all functions have an address
        writing a function name with no arguments yields its address

a pointer variable stores the address of something

    we can't do much with just an address
    all pointers in C are typed
    the type indicates the type of the data
    
int *p; 
    // p is a pointer, it contains the address of an int
int i = 5;
p = &i;
    // p contains the address of i
    // "p points to i"

int j = *p;
    // the * says we are "dereferencing" p
    // we want the value at the address p contains
    
*p = 6;
    // writes a 6 at the location p points to
    // in this case, it changes i
    
    
int *p = &i;
p = &j;

int *p, *q;  // p and q are pointers
int *p, q;   // only p is a pointer
int* p, q;   // only p is a pointer (misleading!)




CS 214 / C Intro/Review
=======================

Office hours: Hill 448
    Monday/Thursday, 2:00 PM - 4:00 PM


declarations and definitions
----------------------------

a declaration describes something
    a function prototype gives the signature of a function
        return type and number and type of arguments
    a global variable declaration says the type of the global variable

a definition creates something
    function definition
    global variable definition

anything we want to use must be defined exactly once
    cannot have two variables/functions with the same name

we can declare something as many times as we want
    - as long as the declarations are consistent
    - every definition is implicitly a declaration

we cannot refer to anything unless it has been declared earlier in the same
file

example: mutual recursion
    void bar(void);     // declares bar but does not define it
    void foo() {  ... bar() ... }
    void bar() {  ... foo() ... }


example: functions defined in other files
    one file, queue.c, contains functions that work with a data structure
    one file, main.c, uses those functions

    problem: we call functions from queue.c in main.c, but main.c
        does not define them
    solution: we declare them in main.c

compiling main.c and queue.c will produce "object files"
    main.o and queue.o
    these contain "unresolved symbols"
        functions are called by name, not by address
        
    the linker will resolve these symbols when creating the executable

header files
------------

a C source file containing declarations
    queue.h
    stdlib.h, stdio.h, unistd.h, string.h, pthread.h
    
these contain
    function prototypes
    global variable declarations (using extern)
    type declarations
    macros (more on that later)
    
these must not contain definitions!
we expect them to be included in multiple source files


example program
    library: queue.c and queue.h
    client: main.c (inclues queue.h)
    
    gcc -c main.c
        -> produces main.o
    
    gcc -c queue.c
        -> produces queue.o
    
    gcc main.o queue.o -o program
        -> produces program



the preprocessor
----------------

this is a program that runs before compilation and modifies your
source code

we control the preprocessor with preprocessor directives
    lines that begin with #

#include <stdio.h>
#include "queue.h"

these tell the preprocessor to include the contents of the specified file
in the source file before compiling

    use <> to indicate a file in the standard include directories
    use "" to indicate a file in the working directory


#include is usually used to include header files, but any file can
be included


macros: tells the preprocessor to replace text in our code

#define MACRO "hello"

    a #define directive adds a macro definition and its replacement
    it will apply to the remainder of the file
    
    puts(MACRO)
    =>
    puts("hello")
    
the preprocessor only replaces complete tokens
    puts(MACROS)
    =>
    puts(MACROS)

the preprocessor does not replace inside string literals

    puts("MACROS")
    =>
    puts("MACROS")
    
    
use macros to define constants
don't use "magic numbers"!


#define ARRAYLENGTH 100

{
    int array[ARRAYLENGTH];
    for (i = 0; i < ARRAYLENGTH; i++) {  ... }
    ...
}


macros replace source code, not values

#define OK     != -1

    if (myfunction() OK) { ... }
    

macros can have parameters

#define check(X)  if ((X) == -1) { puts("Oh no!"); exit(1); }

    check(some_function(arg1, arg2))
    =>
    if ((some_function(arg1, arg2)) == -1) { puts("Oh no!"); exit(1); }
    

#define foreach(P)    for( ; P; P = P->next)

    struct node *p = ...
    
    foreach(p) { stuff involving p }
    =>
    for( ; p; p = p->next) { stuff involving p }
    

#define SQUARE(X)   X * X

    SQUARE(q)
    =>
    q * q
    
    1/SQUARE(a+b)
    =>
    1/a+b*a+b
    
    
#define SQUARE(X)   ((X) * (X))

    1/SQUARE(a+b)
    =>
    1/((a+b) * (a+b))


#undefine ARRAYLENGTH
    removes the definition of the macro for the remainder of a file



conditional compilation:
    include multiple versions of a program/code fragment and select
    which one to use
    

#ifdef SOME_MACRO

    code to use if SOME_MACRO is defined
    
#else

    code to use if SOME_MACRO is not defined
    
#endif


#ifndef SOME_MACRO

    code to use if SOME_MACRO is not defined
    
#endif


#if OS_VERSION < 10

    code to deal with old OS
    
#endif


#ifndef DEBUG
#define DEBUG 0
#endif

if (DEBUG) printf("the value of x is %d\n", x);


defining a macro on the command line
gcc -D<macro_name>
gcc -D<macro_name>=<value>
    these instruct the preprocessor to start with these macros defined
    


#define malloc(X) glorb(X)
#include <stdlib.h>
    whoops, now malloc() is undeclared
    

surprisingly, this sort of thing has non-terrible uses as well
-> look up "feature test macros"


CS 214 / Objects and memory
===========================

No recitation today or tomorrow
Recitations MAY begin on Wednesday; look for an announcement if so


Project I will be assigned within the next 7 days

Objects
-------

An object is a region of memory that we use to store data

- static objects
    - global variables
    - string literals (read only)
    - code (read only)
- stack objects
    - local variables
    - information about active functions (e.g., saved registers, return address)
- heap object
    - dynamic data structures
    
    
static objects exist the entire time the program runs
    they are neither created or destroyed


stack objects are tied to the lifetime of a particular function call
    created when function is called
    destroyed when function returns
    
heap objects are explicitly created and destroyed
    malloc() creates (allocates) an object
    free() destroys (deallocates) an object
    unlike static and stack objects, the size and number of heap objects
        is dynamic


to use an object, we need to know its location and its type
    location says where in memory to look
    type says how much data to get and what to do with it
    
static and stack objects are associated with variables
    the compiler tracks the location and type of each variable's object
    
heap objects are not associated with a variable, so we have no way
    to directly refer to them
    

pointers allow us to indirectly refer to an object
    value of a pointer gives the location of the object
    type of the pointer gives the type of the object

dereferencing a pointer allows us to work with the object it points to

    int n;
    &n
    int *p = &n;
            // p indirectly refers to n
            // *p is the same as n
            
    &p - address of p's object
    int **q = &p;
    
            // *q is the same as p
            // **q is the same as n
            

arrays
------


    int a[20];  // a directly refers to a stack object (array of 20 ints)
    
        a[0]  - directly refers to the first integer in a
        
        a  - evaluates to the address of the array
        &a - also evaluates to the address of the array
    
        *a - directly refers to the first integer in a
    

    int *p;  // declares a pointer variable
    p = a;   // now *p and a refer to the same array object
    
        p     - indirectly refers to first element in a
        p[0]  - directly refers to first element in a
        *p    - directly refers to first element in a
        
        p[5]
        
        p  - evaluates to address of a
        &p - evaluates to address of p


    p = &a[5];  // now p points to a different integer
    
        p[0]   - same as a[5]
        p[1]   - same as a[6]
        p[-1]  - same as a[4]
    
        array indexing can be used with a pointer when
            - the pointer points to part of an array
            - the index lies within the bounds of the array


    int n = get_dimension_from_the_universe();
    p = (int *) malloc(n * sizeof(int));

        // p points to an object on the heap that can store n ints
        // or p is NULL, if malloc() couldn't find space
        
        // an object with space for n ints is indistinguishable from
        // an array of n ints
        
do we need to cast the void pointer from malloc?
 - no, because void pointers automatically promote to any pointer type
 

int *p = malloc(n * sizeof(int));          // ok
int *p = (int *) malloc(n * sizeof(int));  // also ok, maybe redundant


p = malloc(m * sizeof(int));          // ok
p = (int *) malloc(m * sizeof(int));  // also ok, maybe safer




double *q = malloc(n * sizeof(int));
    // valid C, almost certainly a bug
    
    

q = malloc(n * sizeof(int));
    // probably a bug, but hard to see
    
q = (int *) malloc(n * sizeof(int));
    // triggers a type error (int * and double * are incompatible)

q = (double *) malloc(n * sizeof(int));
    // no type error, but obviously wrong


pointer arithmetic
    we can add/subtract integers to/from a pointer
    this gives us a new pointer
        the new pointer will be offset by some number of data items
        depending on its type
        
    int *p;
    p + 1  // indirectly refers to the integer after *p
    p - 1  // indirectly refers to the integer before *p
    
    p + 1 is the same as &p[1]
    
    p[1] is the same as *(p + 1)
        also the same as *(1 + p)
        meaning it is the same as 1[p]
        
    pointer arithmetic is only meaningful if we have a pointer into
        an array, and the result of the arithmetic is within the
        same array


struct node {
    data_t payload;
    struct node *next;
};

struct node *head = NULL;

void push(data_t item)
{
    struct node *new = malloc(sizeof(struct node));
    
    // (*new).payload = item;
    new->payload = item;
    new->next = head;

    head = new;
}
    

in C, we must explicitly deallocate heap objects when we are finished
with them

int pop(data_t *dest)
{
    if (head == NULL) return 0;

    if (dest)   *dest = head->payload;

    struct node *old = head;
    head = head->next;
    free(old);

    return 1;
}


free() only works with objects created by malloc()

    the address we pass to free must be one we obtained from malloc
    
    
    
    int *p, *q;
    p = malloc(20 * sizeof(int));
    q = p;
    
    what is needed to free the array created above?
    1. free(p);
    2. free(q);
    3. free(p); free(q);

    both 1 and 2 will free the array
    but 3 is a memory error (double free)

    int *p = malloc(20 * sizeof(int));
    int *q = p + 10;
    
    free(q);   // nope
    
    
other errors
    use after free: dereference a pointer after it has been freed
    
    
    void free(void *);
    
    


CS 214 / Generic memory operations
==================================

case study: sorting an array

    we might have a function that sorts an array of ints
        
        void sort_ints(int *array, size_t arraylength);
        void sort_floats(float *array, size_t arraylength);
        void sort_strings(char **array, size_t arraylength);
        void sort_strings_descending(char **a, size_t len);
        
    having to write multiple functions are are basically the same
        is frustrating (also bugs hide in duplicated code)
        
we would like a generic sorting function that works with any array
- we need a way to pass the array's address that works for any type
    void *
    
- we need a way to indicate the comparison operation
    solution: pass a pointer to a comparison function
    
        int (*compare)(void *, void *)
        
        typedef int (*comparison_function)(void *, void *);

- we need to specify the element length

void sort(
    void *array,
    size_t arraylength,   // dimension of the array
    size_t elementsize,   // size of elements (in chars)
    int (*comparison_function)(void *, void *)
);



memcpy() - copies data from one object to another

    void *memcpy(void *dest, void *src, size_t length);
        // think like:  *dest = *src;
    
    
    requirements:
        src and dest must point to objects with at least length bytes
        src and dest cannot overlap
        
    you could write your own memcpy, but the memcpy() in the standard
    library will almost certainly be faster
    
memmove() - copies data from one object to another
    regions are permitted to overlap
    
    useful if you aren't certain about disjoint memory
    or, e.g., to shift elements in an array
    


strcpy() - copies a string from one object to another

    char *strcpy(char *dest, char *src);
    
        uses the terminator in src to determine how many bytes to copy
        
        src must be a string (contain a terminator)
        dest must be an object big enough for the string
        
    
    strcpy() does more work than memmove(), because it has to look
        for the terminator
    
    only really useful if we don't know the length of src, but we also
    know it isn't longer than dest
    
        char src[100] = "foo", dest[100];
        strcpy(dest, src);
    
    often, we will know how big src is; then just use memcpy()
    
        int len = strlen(src) + 1;
        char *dest = malloc(len);
        memcpy(dest, src, len);
    
        // or use strdup(), if you have it
        
strncpy() - copies a string (up to n bytes) from src to dest

    char *strncpy(char *dest, char *src, size_t n);
    
        will not write more than n bytes to dest
        - but if it writes n bytes before it finds the terminator,
            it won't write a terminator to dest

        it is unclear how this is useful

further reading:
    memset()
    calloc()
    realloc()
        
-----

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>    // but why?

void sort(void *array, size_t alen, size_t esize, int (*compare)(const void *, const void *))
{
    int i, j;
    char *base = array;
    char *temp = malloc(esize);

    for (i = 0; i < alen; i++) {
        for (j = 1; j < alen; j++) {
            char *prev = base + (j - 1) * esize;
            char *this = base + j * esize;
            if (compare(prev, this) > 0) {
                // swap
                memcpy(temp, this, esize);
                memcpy(this, prev, esize);
                memcpy(prev, temp, esize);
            }
        }
    }

    free(temp);
}

int compare_ints(const void *a, const void *b)
{
    int x = *(int *)a;
    int y = *(int *)b;
    return x - y;
}

int compare_strings(const void *a, const void *b)
{
    char *x = *(char **)a;
    char *y = *(char **)b;

    return strcmp(x, y);
}



#define ALEN 5
#define BLEN 4

int main(int argc, char **argv)
{
    int A[] = { 8, 3, 25, 0, -9 };
    char *B[] = { "foo", "bar", "quux", "falala" };

    sort(A, ALEN, sizeof(int), compare_ints);
    sort(B, BLEN, sizeof(char *), compare_strings);

    for (int i = 0; i < ALEN; i++) {
        printf(" %d", A[i]);
    }
    printf("\n");

    for (int i = 0; i < BLEN; i++) {
        printf(" %s", B[i]);
    }
    printf("\n");

    return EXIT_SUCCESS;
}

CS 214 / StrBuf and make
===========================

Project I will be posted later tonight (or early tomorrow)
We will discuss the content of Project I on Wednesday

Recitations will start on Wednesday


StrBuf
------

a stretchable character array with efficient append

data structure
- backing array (identity of array may change over time)
- size of backing array (array capacity)
- size of the string


operations
- add a character
- append a string
- initialize
- destroy



files:
strbuf.c   - implementation of functions
strbuf.h   - type definitions and function prototypes
driver.c   - client code

    driver.c includes strbuf.h (to that it has the prototypes)
    strbuf.c includes strbuf.h (ensure prototypes are consistent)
    
compilation process
    compile strbuf.c to strbuf.o
    compile driver.c to driver.o
    link strbuf.o and driver.o into driver
    

expanding the array
1. use malloc() to allocate a bigger array
2. use memcpy() to move current array to new array
3. use free() to deallocate the original array

... but realloc() does all these

void *realloc(void *, size_t);

    we provide a pointer to an object (or NULL) and a desired size
    if it can, realloc will make the object bigger
    if it can't, realloc will do the steps listed above
    
realloc() returns a pointer to the object, which may have moved
-> we have to assume that it has moved

common usage pattern
    p = realloc(p, new_size);
    
but this causes problems if realloc fails (and returns NULL)

safer pattern:
    void *q = realloc(p, new_size);
    if (q == NULL) { // report error or something }
    else p = q;
	
	
	
make
----

tool to automate compiling (building) large projects

you create a make file that says how to create certain files

<file name>: <list of dependencies>
	<commands to create file>
	<or just do something>
	
commands must be indented by a single tab character -- no spaces!


strbuf.o: strbuf.c strbuf.h
	gcc -c strbuf.c
	
driver.o: driver.c strbuf.h
	gcc -c driver.c

driver: driver.o strbuf.o
	gcc driver.o strbuf.o -o driver


when we ask make to create a target, it:
1. checks whether dependencies are up to date
2. checks whether the target is newer than its dependencies
3. if the target is older than at least one dependency, run the commands


we can call make with zero or more arguments
with one or more arguments, make will build all the specified targets
with no arguments, make builds the first target in the file

    -> typically, we would put the rule for the program first
    -> then we can just type 'make' to recompile everything

make -B <args>
	run as though everything is out of date


variables in makefiles
----------------------

to define a variable

VAR_NAME = some text

to use a variable
	$(VAR_NAME)
	
commonly used variables

CC = gcc
CFLAGS = -g -Wall -std=c99 -fsanitize=address -O2


driver: driver.o strbuf.o
	$(CC) $(CFLAGS) driver.o strbuf.o -o driver

driver.o: driver.c strbuf.h
	$(CC) $(CFLAGS) -c driver.c

strbuf.o: strbuf.o strbuf.h
	$(CC) $(CFLAGS) -c strbuf.c


make has a built-in rule to create a .o file from a .c file


generalized recipes
-------------------

we get three more variables when executing a recipe

    $@ - name of the target
    $^ - list of dependencies
    $< - first dependency
	

wildcard recipes

%.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@


we can use recipes with no commands to indicate extra dependencies

driver.o: strbuf.h
strbuf.o: strbuf.h

or combine them

driver.o strbuf.o: strbuf.h











	






	

CS 214 / You, your malloc, and you
==================================

Recitations started tonight
Project I group sign-up sheet on Canvas


mymalloc and myfree
- take additional arguments: file name and line number
    these are used to provide more informative error messages
    
    free: attempt to free non-object (file.c:123)
    

- provided malloc() and free() macros will automatically fill in
    the file name and line number arguments
        
    preprocessor replaces
        __FILE__ with a string literal containing the file name
        __LINE__ with an integer literal that is the line number


internally, your library will use a static global array as its heap

#define MEMSIZE 512

static double memory[MEMSIZE];

"static" keyword makes the global variable private to this source file
    it does not participate in linking
    -> prevents other code from touching our variable
    
"double" has no significance, aside from ensuring 8-byte alignment
    -> we will not use this as an array
    
alignment:
    primitive N-byte data should be at addresses divisible by N
    - ensures that data is stored in a single cache line
    - ensures that two primitive data items will not overlap
    
- how does malloc() deal with alignment?
    knowing the size of an object does not tell us its alignment
    malloc(40)
        could be
            5 doubles (alignment 8)
            10 integers (alignment 4)
            20 shorts (alignment 2)
            40 chars (alignment 1)
    we are not allowed to use unaligned pointers in C (undefined behavior)
    how can malloc know the alignment of the data?
    it can't! it just guarantees the largest alignment for the hardware


how to round up to a multiple of 8

    7   - all zeros followed by 3 ones
    ~7  - all ones followed by three zeros
    
    n & ~7  - n rounded down to the nearest multiple of 8
    
    (n + 7) & ~7   - n rounded up to the nearest multiple of 8
    

errors to detect

1. malloc way too much memory
2. malloc more memory than any available free block

3. free an object not in the heap
4. free an object that is already free
5. free a pointer not at the start of an object




#define heap ((char *) memory)

to get a pointer at n bytes into the heap, write heap + n


we can cast pointers at will

    ((struct header *) (head + offset))->size
    
    
#define blocksize(offset)   *(int *)(((char *) memory) + offset)
#define allocated(offset)   *(int *)(((char *) memory) + offset + 4)
    
    int offset = 0;
    
    size = blocksize(offset);
    
    offset += blocksize(offset);



testing strategy

1. figure out required properties of your library
    "when malloc allocates an object, it does not overlap any other object"
2. figure out how to know if these properties have been violated
    "writing to one object should not change the contents of any other object"
3. write test cases to try to cause violations
    memtest.c
    
having a well thought-out test plan is essential for writing complicated
    software


CS 214 / Project, file IO
=========================

run-time errors
    improper use of the library which your code must detect
    - malloc too much memory, free a bad pointer
    
    mymalloc should return NULL and print an error message
    myfree should do nothing and print an error message
        or print an error message and terminate the program (EXIT_FAILURE)
        

programming mistakes
    errors in your library code that you should detect and fix
    
    reason about your code and run tests to increase your confidence
        that your code is correct
    
    coming up with a testing strategy
    1. think of requirements that your program/library must satisfy
        - library must detect and report the run-time errors above
        - mymalloc should allocate memory on your heap
        - myfree should deallocate memory on your heap
    
    2. think how you would know if these requirements were violated
        - if we allocate all of memory, we shouldn't be able to allocate more
    
    3. write specific test cases/test programs
        - write a program that allocates e.g. 4088 bytes, then
            tries to allocate 100 bytes (expected to fail)
        - write a program that allocates all of memory, frees it,
            and then allocates again (expected to succeed)

----

int main(int argc, char **argv)
{
    int test = atoi(argv[1]);   // FIXME
    int n;
    char *p;
    
    switch (test) {
    
    case 1:
        free(&n);
        break;
    
    case 2:
        p = malloc(25);
        free(p);
        free(p);
        break;
        
    case 3:
        p = malloc(25);
        free(p + 10);
        break;
        
    }
    
    return EXIT_SUCCESS;
}


----

performance testing
    gauge the efficiency of our code
    
    memgrind.c is intended to test your code efficiency
        write test cases that you would expect poor performance for
    
    way to get average time/test
        - get the current time (start time)
        - run test 50 times
        - get the current time (stop time)
        - compute elapsed time (stop time - start time)
        - average time = elapsed time (in ms) / 50


use make to simplify your life


test: test-program
    ./test-program
    
test2: test-program
    ./test-program > test2.out
    diff test2.out test2.ref


useful/recommended compiler options

    -g          enables debugging information/symbol tables
    -Wall       emit most useful warning messages
    -Wvla       emit warnings for variable-length arrays
    -std=c99    disable GCC extensions and C2011 features
    
    -fsanitize=address    compile with address sanitizer (ASan)
    -fsanitize=undefined  compile with undefined behavior sanitizer (UBSan)
        -fsanitize=address,undefined
    
    -O   optimize code
    -O2  optimize code more




file IO
-------

a file in Unix is a stream of bytes
    prior to unix, mainframe OSes defined files a sequences of records
-> byte streams are more flexible and general, but require more
    work for the program itself


Unix generalizes the file interface to work with all byte streams
- actual files on disk
- console input/output
- other IO devices
- inter-process communication (IPC)
- network communication

all of these share the idea of sending/receiving a stream of bytes

there are some specific differences
- some files may be read-only or write-only
- some files may allow random access

in C, we have two sets of file functions

C language standard provides
    fopen, fclose, fread, fwrite, fscanf, fprintf
    indicate file using FILE *
    buffered
    part of <stdio.h>
    
POSIX operating system standard provides
    open, close, read, write, lseek
    work with file descriptors
    not buffered
    lower-level (these functions directly correspond to syscalls)
    more general
    part of <unistd.h>, <fcntl.h>

a file descriptor is an integer
    the run-time system maintains a table of all open files
        the descriptor is an index into that table
        -> this table is also kept by the OS
    
    typically:
        0 is standard input (STDIN_FILENO)
        1 is standard output (STDOUT_FILENO)
        2 is standard error (STDERR_FILENO)
        
    fileno() returns the file descriptor used by a FILE
    fdopen() creates a FILE for a file descriptor


buffering
    problem: communicating with a file is a system call (syscall)
        -> OS calls are more expensive than normal function calls
        -> require a "context switch"
    
    if we are reading a file byte-by-byte, we don't want to do a syscall
        for every byte
    instead, we request a bunch of bytes at once and store them in
        an array (called a buffer)
        
    for writing, we collect bytes in a buffer and then send them all
        at once

the FILE struct contains an internal buffer
    individual calls write to the buffer
    when the buffer is full, the whole buffer is "flushed" to the OS
        exceptions: a FILE can also be line buffered (flush whenever
            a newline is written) or non-buffered (flush after the
            fprintf is done)
            
    fflush() forces a buffer to flush
    you can lose data if your program crashes with unflushed data
        in a buffer

the posix functions do not have an internal buffer:
you buffer your own data
    read() and write() accept arrays of bytes to write to/read from
    
ssize_t read(int fd, void *buffer, size_t n);
    asks OS to write up to n bytes into the array at buffer
    returns the number of bytes read
    returns 0 at end of file
    returns -1 for error conditions

    

CS 214 / Posix File IO
======================

open
----

#include <fcntl.>
int open(char *pathname, int flags);
int open(char *pathname, int flags, mode_t mode);


pathname: indicates how to find the file we want to open
    a name by itself (with no slashes) indicates a file in the working directory
    
    a path contains one or more names separated by slashes
        slashes indicate directory containment
        
        foo/bar/baz  "baz" inside "bar" inside "foo" inside the working directory
        -> called a "relative path"
        
    a path that begins with / is an absolute path, starting from
        the file system root
        e.g., /usr/bin/gcc
    
    special directory entries
        ..   means the parent directory
        .    means the directory itself
    
        ../foo  means "foo" in the parent of the working directory

flags are an integer (bitmap) indicating how we want to use the file

flags must include exactly one of:

    O_RDONLY   - open file in read mode
    O_WRONLY   - open file in write mode
    O_RDRW     - open file in read/write mode

we can combine with additional flags using | (bitwise or)

    O_CREAT  - create file if it does not exist (requires mode)
    O_EXCL   - fail if the file already exists
    O_TRUNC  - set the file length to 0, if it exists
    O_APPEND - all writes go to the end of the file
    O_NONBLOCK - open file in non-blocking mode (doesn't matter much for disk files)


on success, open() returns a file descriptor (non-negative int)
    this is guaranteed to be different from any *currently* open file

on failure, open() returns -1 and puts an error code in errno

    int fd = open("foo.txt", O_RDONLY);
    if (fd < 0) { // report error or something }

        
errno
-----

errno is global variable that some functions use to report error conditions

the man pages for library functions will describe how functions
report errors and whether they use errno and what values they use

the library defines macros for all error codes
    EACCES - don't have permission to read/write file
    EINVAL - path is invalid
    EEXIST - file already exists

in principle, we can use errno to learn why something went wrong
and try to fix it

in practice, we use errno to provide more specific error messages

void perror(char *msg);
    
    prints a message incorporating msg and a description of errno
    
    
    int fd = open(some_file, O_RDONLY);
    if (fd < 0) {
        perror(some_file);  
            // prints a message that looks like
            // some_file: reason we couldn't open some_file
        abort();
    }


char *strerror(int error_code);
    returns a string describing the error code
    
    
    fprintf(stderr, "%s: %s\n", msg, strerror(errno));
    

file permissions
----------------

the mode refers to the traditional way to indicate file access permissions
    in Unix
    
every file has an owner (a user account)
every file is associated with a group (a list of user accounts)

three categories of users
    u - the owner
    g - the group (except the owner)
    o - everyone else

for each category, there are three permissions
    r - read access
    w - write access
    x - execute access (run a file or access a directory)


uuugggooo
rwxrwxrwx

the shell command chmod can change the mode of a file

    chmod <code> <file>
    
    codes are [ugoa][+-][rwx]
    
        u+rwx  - give owner read/write/execute permission
        a-wx   - remove write/execute from all users
    
    we can also specify an exact mode by giving three octal digits
    
    7 in octal is 111 in binary, meaning rwx
    6 in octal is 110 in binary, meaning rw-
    5 in octal is 101 in binary, meaning r-x
    
    chmod 700 file   - sets rwx------
    chmod 644 file   - sets rw-r--r--

when we open a file with O_CREAT, we specify the mode of the file
    to create as an integer
    
    fd = open(name, O_WRONLY|O_CREAT|O_TRUNC, 0640);
        // the permissions we want to give are u+rw, g+r
        
reminder: in C, an integer literal starting with 0 is in octal!

    0100 == 64
    0x40
    
the library also provides constants that you can combine to create
    a mode
    
    0640
can also be written
    S_IRUSR|S_IWUSR|I_SRGRP


close
-----

#include <unistd.h>
int close(int fd);

    closes the indicated file
    on success, returns 0
    on failure, returns -1 and sets errno

any files that are still open when the program ends will automatically
    be closed
    
    either by the run-time system or by the OS

each process has a limited number of simultaneously open files
    if you open a lot of files, you could run out
    it is good practice to close files once you are finished with them


read
----

ssize_t read(int fd, void *buf, size_t n);

    reads up to n bytes from a readable file
    fd indicates the file to read from
    buf is an array of bytes to write to
    
    on success, read returns the number of bytes read (at least 1)
    read returns 0 at the end of the file
    on failure, read returns -1 and sets errno
    
every open file has a file position (aka a file pointer or cursor)
    when we read a file, the position starts at the beginning
    each time we read, the position advances



    char buf[BUFSIZE];
    int r;
    
    r = read(fd, buf, BUFSIZE);
    while (r > 0) {
        // do stuff with buf
        
        r = read(fd, buf, BUFSIZE);
    }
    // done
    
or, if you don't like repeating yourself

    char buf[BUFSIZE];
    int r;
    
    while ((r = read(fd, buf, BUFSIZE)) > 0) {
        // do stuff with buf
    
        for (i = 0; i < r; i++) {
            if (isspace(buf[i])) space_count++;
        }
            
    }
    // done


write
-----

ssize_t write(int fd, const void *buf, size_t n);

    writes up to n bytes to a writable file
    fd indicates the file
    buf contains the bytes to be written
    
    returns the number of bytes that got written (at most n)
    returns -1 on failure and sets errno
    

    int a[] = { 1, 2, 3, 4 };
    
    write(fd, a, sizeof(a));
    
    \1\0\0\0\2\0\0\0\3\0\0\0\4\0\0\0





CS 214 / Reading files
======================

Late assignment submission
    - Canvas is the arbiter of time
    - submit by 11:59 PM
    - late penalty is 10 points per day
        this is not pro-rated
        if you can't make the deadline, don't stay up all night
    - late penalties will not reduce your score below 60

What goes in the README
    - name and netID of both partners
    - any additional information needed to compile and run your program(s)
        - e.g., what arguments your test programs take
    - design notes
    - testing plan/strategy
        briefly note your requirements and how you checked them
            and why
    - your two performance tests
        what are they and why did you pick them?
        did you learn anything?


reading files
-------------

open() is used to open a file
    it returns a file number (file descriptor)

read()  reads data from a file and copies it to a buffer
write() reads data from a buffer and writes it to a file
    both read and write are system calls
    -> inherent overhead from calling into the OS (context switch)
    -> we use buffers to amortize the cost per byte

when we are reading from a file, how much should we read?

for binary formats, the format may be divided into portions of a known
    length


    int fd = open(data_file, O_RDONLY);
    if (fd < 0) { ... }
    
    int n, *p, bytes;
    
    bytes = read(fd, &n, sizeof(int));
    if (bytes < sizeof(int)) { .... }
    
    p = (int *) malloc(n * sizeof(int));
    bytes = read(fd, p, n * sizeof(int));
    if (bytes < n * sizeof(int)) { ... }


when dealing with text, we don't have fixed length units
    lines, words, etc. can be any length

strategy:
    choose a convenient buffer size
    read data from a file
    search buffer for the things we are looking for
    
    issues:
        partial units at the end of the buffer
        units may be longer than the buffer


Code examples posted on Canvas under Source Code/lines

CS 214 / Files & File system
============================

Producer/Consumer

    producer: reads file and generates data items (e.g., lines)
    consumer: receives items and uses them in some way

control passes back and forth between producer and consumer
both producer and consumer might need to store some state

how do we organize code like this?

- everything in one function
    - all the state can be in local variables
    - function is more complicated (doing two separate things)
    - can lead to code duplication
        - might consume in different places
        - might want to do different things

- producer-driven (enumerator)
    primary loop(s) focus on getting the next data item
        call a function to receive the item

- consumer-driven (iterator)
    primary loop is in the consumer
        calls a function to get the next item
        
- mulithreading
    run producer and consumer in separate threads
    send data through shared data structures
    both more and less complicated


two approaches to managing memory: persistent and ephemeral
    when the data items are objects like strings, we have to consider
    when they get deallocated and what code is responsible


persistent approach
    producer allocates a fresh object for each item
    ownership is transferred to consumer
        consumer must (eventually) deallocate the object

ephemeral approach
    producer allocates memory for items
    item is only valid for a short time (until the next item is produced)
    producer will deallocate the object
        if the consumer wants to hang on to an item, it must
            make a copy

the persistent approach requires an allocation for each item
    the ephemeral approach does not

the persistent approach is fairly easy to understand
    maybe not the ephemeral approach so much?


all these approaches have merit
choose the one that fits your program and your mind


file system
-----------

how do we refer to files?

at the user level, we refer to files by path name

    /path/to/some/file
    
    a path name identifies a single file
    
the file system refers to files by number (i-node identifier)

    i-node: "index node" (probably)
    
an i-node is a block on the storage device that stores information
about a file

the file contents are stored in data blocks
    the data blocks making up a file are not contiguous
    -> the i-node needs to indicate which data blocks the file uses


some requirements:
    - quick access to every part of the file
    - able to represent large files (millions of blocks)
    - efficiently represent small files
    - all i-nodes are the same size (needed for efficient look-up)

unix approach
- inode contains some number of direct references (e.g., 10 blocks)
- "single indirect" block
    refers to a data block containing block references
    e.g., 100 block references
- "double indirect" block
    refers to a data block referring to single indirect blocks
    e.g., 10,000 block references
- "triple indirect" block
    refers to a block containing double indirect references
    e.g., 1,000,000 block references


what else is stored in the i-node?

- type
- timestamps (created, modified, accessed)
- owner and group names
- mode (permissions)
- size of the file (in bytes and blocks)


one notable omission: file name

the file's name is implied by the directory structure

a directory is a special file containing a list of directory entries
    each having (at least)
        a name (local)
        an i-node ID


when we look up /foo/bar/baz

1. open directory file for / (always in a known location)
2. look for entry labeled "foo", get inode id (X)
3. open directory file X
4. look for entry labeled "bar", get inode id (Y)
5. open directory file Y
6. look for entry labeled "baz", get inode id



implication: files can easily have more than one name
    in fact, the inode tracks how many names a file has

we can use ln to make new names for existing files

    ln <existing file> <new name>
    
when we remove a file, we unlink its name
this reduces the number of names that a file has
    files are deleted when they have no names and no program has them open


a directory entry is known as a "hard link"
    connects a name to an ID


symbolic link
-------------

a symbolic link is a special file that contains a path

normally, opening a symbolic link will open the path instead


    ln -s <existing file> <new name>

symbolic links point to a name, not a file
-> they can break if the file is deleted or renamed
-> we can change which file the link points to by renaming them


you can make symbolic links to directories
you can't (normally) make new names for directories









CS 214 / Directories
====================

Recap:
    a directory is a special file that contains directory entries
    each directory entry has (at a minimum)
        - file name
        - inode identifier

    every directory has two special entries
        .   - always refers to the directory itself
        ..  - always refers to the parent of the directory
        
two ways to open a directory file

    open()  - gives access to the raw bytes (not usually necessary)
    
    opendir()  - convenient way to iterate through directory entries
    
#include <dirent.h>

DIR *opendir(char *path);

    opens the specified directory and returns a handle
    on failure, returns NULL and sets errno
    
struct dirent *readdir(DIR *handle);

    returns the next entry in the directory
    returns NULL if we have read all the entries
    
    struct dirent contains at least these fields
        int_t d_ino;    // i-node identifier
        char d_name[];  // file name (null-terminated string)
        
    the pointer we get is only valid until the next call to readdir()
        or a call to closedir()

int closedir(DIR *handle);

    closes the specified open directory
    returns -1 and sets errno on failure



note: readdir() returns entries in no particular order
    (possibly the order that entries are stored in the directory file)


stat
----

int stat(char *path, struct stat *data);

    on success, fills out the specified struct with info about the file
    on failure, returns -1 and sets errno
    
    
struct stat contains information about the file, including
    dev_t st_dev;   // id of the device containing the file (disk)
    int_t st_ino;   // inode identifier for the file
    mode_t st_mode; // mode information (permissions, etc)


using the mode, we can learn things about the file including
    permissions
    file type
    
    
    S_ISREG(m)   - true for regular files
    S_ISDIR(m)   - directories
    S_ISLNK(m)   - symbolic links
    
struct stat sbuf;

int r = stat(pathname, &buf);
if (r < 0) { ... }

if (S_ISREG(buf.st_mode)) {
    // regular file
} else if (S_ISDIR(buf.st_mode)) {
    // directory
} else {
    ...
}

reference
    man 2 stat
    man 7 inode


the shell
---------

shell commands start with the command name
    bare name - look for a program in the specified directories
    path      - indicates a specific program

    cp  - will be found in /usr/bin
    /usr/bin/cp  - absolute path indicating program
    ./cp  - relative path (indicating cp in the working directory)
    
shell wildcards

    ?  - wildcard that can be replaced by any character
    *  - any sequence of zero or more characters (excluding /)
    
the shell replaces words containing a wildcard with files matching
    the word
    
example: current directory contains a.txt, b.txt, cd.txt

    ls ?.txt
        shell replaces this with
    ls a.txt b.txt
    
    ls *.txt
        shell replaces this with
    ls a.txt b.txt cd.txt

./spchk dict foo*.txt  

 subdir/*.c 
 
 subdir/*/*.c
 
 
 
mv <old_name> <new_name>

    either renames the first file or moves the file (if the new name is
        an already existing directory)

mv <many names...> <destination directory>


implication: we can't rename multiple files at once

    mv *.c *.cpp
        doesn't work!
        can't work!




    

    
    







CS 214 / Processes
==================

Midterm Exam: Wednesday, March 6, in class
    I will post a topic list and discuss it Monday
    You may bring 1 page (single sided) of handwritten notes
    
Format: primarily short answer questions (a few sentences at most)
    Some code reading, very little code writing


Project II will be due March 18


shell
-----

recall:
    search path used for first word in command (except for paths)
    
        prog    run a program "prog" in the search directories
        ./prog  run a program "prog" in the working directory

    PATH is the list of directories to search for programs


file globs
    specify one or more files
    
    * matches any sequence of characters
    ? matches any one character
    
    the shell expands globs before executing the program
    

stdin, stdout, stderr
    normally, these files are inherited from the shell 
        (or other parent process)
    
    redirection lets us change these
    
    some_program < foo
        use the file "foo" as standard input
        
    some_program > bar
        use the file "bar" as standard output
    
    some_program < foo > bar
        use "foo" as stdin and "bar" as stdout
    
    some_program >> bar
        use "bar" as stdout in append mode
        
    
    some_program 2> errs
        use "errs" as stderr
    
    some_program 3< foo 4> bar
        open "foo" for input as file number 3
        open "bar" for output as file number 4
        

## pipes

use pipes to chain two or more programs together,
    where the output of one program becomes the input of the next


    some_program | grep ERROR
    
        runs some_program and grep
        stdout for some_program writes to stdin for grep
        
    some_program | grep ERROR | sort | uniq -c


    some_program | tee file
    
        tee reads from stdin (the output of some_program)
        it sends what it reads to the file and to stdout

useful programs

wc - counts characters/words/lines in a file 

cat   - reads several files and writes them to stdout
more  - reads from a file or stdin and paginates its output
less  - more powerful version of more (lets you go backward)


    cat *.c | grep foo

    cat chapter*.txt > whole_thing.txt
    
grep - search files (or stdin) for lines matching a pattern

    grep ERROR files...
        print all lines containing ERROR    
    grep ^ERROR
        print all lines beginning with ERROR
    
    grep 'foo.*bar' files
        print lines containing "foo" followed at some point by "bar"

    grep "[0-9]" files
        print lines containing a digit

grep regular expressions are very powerful
many tutorials exist on-line


## exit status

    $?   - shell variable containing the exit status of the last process
    

foo && bar

    executes foo
    if foo succeeded, executes bar

    make prog && ./prog

foo || bar

    executes foo
    if foo failed, executes bar
    
    ./prog || echo "Failure!"
    

processes
---------

a process is a program that is being executed
    
    a process includes the state of the computer (memory, files, etc)
        as well as a program it is executing

    every process has a unique process ID (PID)
    

in Unix, a process group is a collection of one or more processes
    a process group created by a shell is a "job"
    
    running a single program starts a job
    all processes in a pipeline are part of the same job
    

a session is a set of process groups
    typically, each time you log into a system, you get a new login session
    every job and process you start will be part of this session


    a login session can be associated with a terminal
    
process groups can be in the foreground or the background


useful control codes:
    ^C   interrupts (terminates) every process in the foreground
        process group
    ^Z   stops (pauses) every process in the foreground progress group
        the parent becomes the foreground
        
        
fg   - brings a stopped job back to the foreground
bg   - resumes a stopped job in the background


jobs - lists all active jobs with their status
ps   - lists all processes in the current session

    ps -e   - lists all processes

put & at the end of a shell command to start the job in the background

    long_program > lp.out & 
    

    gedit file.c &
        <- run gedit in the background, so you can still use the shell


kill
    sends a signal to a process
    
    by default, sends TERM (tell process to terminate)

kill -KILL
kill -9
    kills a process with no opportunity to block


what happens to processes running in the background when I log out?

    they are sent HUP ("hang up")
    by default, a process receiving HUP will terminate

nohop shell command
    runs the shell command but blocks the hang-up signal
    
    nohup ./test_server
    

note: HUP, INT, TERM, and KILL terminate a program
    STOP stops a program
    a stopped program can be resumed, a terminated program cannot


creating processes
------------------

pid_t fork(void);

    creates an identical duplicate of the current process
    in the original process, fork() returns the PID of the new process
    in the child process, fork() returns 0


pid_t child = fork();
if (child == 0) {
    // we are in the child
    ...
    exit()
}

// we are in the parent


the child process begins as a duplicate of the parent:
    same program
    same contents of memory
    same instruction pointer 
    same open files
    different process ID
    
once fork returns, the parent and child will (most likely) diverge


after calling fork(), the parent must (eventually) call wait()

pid_t wait(int *wstatus);

    blocks until a child terminates
    returns PID of the child that terminated
    if we give it a pointer, it will write an int containing the exit status
    

puzzle:

    what does this do?
    
    for (int i = 0; i < 5; i++) {
        fork();
    }
    

    why is this a terrible idea?
    
    while (1) {
        fork();
    }








CS 214 / Multitasking
=====================

Project II notes
----------------

- the dictionary is specified as an argument each time the program runs
    -> make no assumptions about dictionary length/content
    
- you are only resposible for handling ASCII characters (0-127)
    -> /usr/share/dict/words is unfortunately UTF-8, so some words have
       characters outside that range
    -> it is safe to ignore words with non-ASCII characters

- ctype.h has many useful functions/macros: isalpha(), isupper(), tolower()

- for our purposes, all characters are letters, whitespace, or other
    -> treat symbols, numbers, control characters like punctuation
        
- if you can't get all the features working, get as many as you can

apple   => apple, Apple, APPLE
Rutgers => Rutgers, RUTGERS
NSA     => NSA

MacDonald   => MacDonald, MACDONALD
fooBar      => fooBar, FooBar, FOOBAR

aBc => aBc, ABc, ABC
    not: abc, abC, aBC, Abc, AbC


Exam topics
-----------

C programming
    - general syntax
    - preprocessor, use of #include
    - standard library
    - helpful tools: gcc, make, man
        -> man (the manual) is divided into sections
            POSIX functions are in section 2
            C standard functions are in section 3
    - declarations and definitions
            function definition vs prototype
    - preprocessing vs compiling vs linking
        - how is linking used to support separate compilation?
    - types
        - char, int (various), float, double
        - struct, union, enum
        - arrays
        - pointers
        - sizeof()
            - array variable vs pointer to array
    - macros
        - macro expansion
        - considerations when defining macros with arguments 
            (recommended parentheses)
            
            #define SQUARE(X)  X * X
                    <- needs more parentheses, but where and why?

        - checking macro expansion with gcc -E
        - use of \ to continue definitions

#define strict(X) \
    if ((X) == -1) { \
        perror(""); \
        exit(EXIT_FAILURE); \
    }

Memory 
    - understanding all data as collections of bytes
    - pointer vs "pointee"
    - pointer types and pointer arithmetic
    - object location vs object content
        int a;   a vs &a 
        int *p;  p vs *p vs &p
    - use of malloc(), realloc(), and free()
        int *p = malloc(...);
        int *q = p;
        p = realloc(p, ...)
        *q   /// potentially use-after-free

Posix File IO
    - open(), close(), read(), write()
        open("foo", O_WRONLY|O_CREAT|O_TRUNC, 0777);
    - use of buffers
    - opendir(), readdir(), closedir()

File system
    - inode block vs data block
    - directory files
        - file names
    - "linking" files
        -> can a file have more than one name?
        -> can a directory be linked more than once?


0 = /
    .   0
    ..  0
    foo 1

1 = /foo
    .   1
    ..  0
    bar 2
    baz 3

2 = /foo/bar
    .   2
    ..  1
    qux 4

3 = /foo/baz
    .   3
    ..  1

4 = /foo/bar/quux
    .   4
    ..  2
    

multitasking
------------

a CPU executing a program is doing a task
a task involves
    - a program being executed
    - stack
    - instruction pointer, registers


multitasking refers to execution of multiple tasks concurrently
    why?
    
    tasks typically spend a lot of time waiting for input (blocked)
    -> multitasking allows the CPU to keep busy while waiting for IO

    responsive interactive programs
        -> UI can respond to input while complex computations occur in
            background

    take advantage of multiple CPUs (multiprocessing)

task switching
    -> every so often, the CPU suspends the current task and starts
        or resumes executing some other task
    
    when do we switch tasks?
    cooperative multitasking
        - when a task blocks, or when it explicitly yields control
    preemptive multitasking
        - when a task blocks or runs out of time
        - the scheduler assigns each task a slice of time


virtual memory/protected memory
    pointers in user programs refer to "logical addresses"/"virtual addresses"
    the memory bank locates data using "physical addresses"
    
    the memory management unit in the CPU maps logical addresses to
        physical addresses -> per process
    
    -> two processes can use the same logical address without inteference
        because they refer to distinct physical addresses
    -> one process cannot interfere with another's memory
    
a process has
    - a virtual memory
    - one or more tasks
    

creating a process
------------------

pid_t fork(void);

    when a process (the parent) calls fork(), it creates a clone of itself
        (called the child)
    the child is initially identical to the parent
    
    on success:
        fork returns 0 in the child
        fork returns the PID of the child in the parent
    on failure, it returns -1 and sets errno
    

    pid_t child = fork();
    if (child == 0) {
        // in child
        exit(...);
    }
    // in parent
    
    
    pid_t a = fork();
    pid_t b = fork();
    
    |
    +----+
    |    |
    +-+  +-+
    | |  | |


if you fork, you must wait

pid_t wait(int *wstatus);

    if a child process has terminated, obtains its exit status
    if a child is still running, block until it terminates
    if no child is running, return -1 and set errno
    

every process is listed in the process table
    when a proces terminates, it remains in the process table as a "zombie"
    the entry for a zombie process indicates how it terminated

calling wait() with at least one zombie child will obtain
    the information and "reap" (remove) its table entry
    

if the parent terminates before the child, the child becomes an "orphan"

    if the child terminates/has terminated, it is a "zombie orphan"
    problem: normally, only the parent can wait for (reap) a child
    
typically, some process in the OS (init) will "adopt" orphans and
    reap them when they terminate





what can a child process do?

-> execute a different program
    (does not create a new process)

    execl() and execv() change the program that the process is running
    
    int execl(char *path, ...);
    int execv(char *path, char **args);
    
    
    execl("/usr/bin/ls", "/usr/bin/ls", "-l", NULL);
    
    
    char *args[] = { "/usr/bin/ls", "-l", NULL };
    execv("/usr/bin/ls", args);
    


    
    
    
if (fork() == 0) {
    execl(...);
    
}
wait()

CS 214 / Processes
==================

Process - executes a program
    - program code
    - memory (stack, heap)
    - list of open files
    - process id (PID)
    - process group id (PGID)
    - session id

Process group - one or more processes
    - used to group together related processes
        e.g., all the processes in a pipeline
    - called a job when it is created by a shell command
        the shell tracks the process groups it creates and assigns them
        job numbers
    - one process group is in "the foreground"
        - meaning it receives input from the terminal
        - notably, ^C and ^Z signal every process in the foreground group

Session - groups together processes started in a single log-in session
    - all processes share a terminal
    - when you log out, all processes in the session receive HUP
        ("hang-up")
        


we create new processes using fork()

pid_t fork(void);

    fork creates a new process (the child)
    the child starts out as a clone of the current process (the parent)
    
    in the parent, fork returns the PID of the child
        (or -1 if fork failed)
    in the child, fork returns 0
    
both processes run concurrently (for now)

pid_t child = fork();
if (child == 0) {

    // in child 
    
    exit(...);
} else if (child == -1) {
    perror("huh?");
    exit(1);
}

// in parent

once you create a child process, you must wait for it to terminate

pid_t wait(int *wstatus);

    if a child process has terminated, immediately returns
    otherwise, block until a child process terminates
    
    returns the PID of the terminated child
    writes exit status information to wstatus
    
    once wait returns, we know the child has finished
    we must call wait() once for each time we call fork()
    
a process becomes a "zombie" when it terminates
    when its parent calls wait, it is removed from the process table

a process becomes an "orphan" when its parent terminates
    when an orphan terminates, it becomes an orphan zombie
    typically, the OS will have a process that "adopts" orphans



often, we want the child process to run another program

    int execl(char *path, ...);
    int execv(char *path, char **args);
    
    path says where to find the executable to run
    the remaining argument(s) determine argv in the new program

    execl("/usr/bin/sort", "sort", "my_file", NULL);
                            argv[0]   argv[1]   tells execl no more args
                    
    
    char *args[] = { "sort", "my_file", NULL };
    execv("/usr/bin/sort", args);

        array must have NULL as its last entry
    
    
on success, exec does not return!
    current program is discarded
    process begins executing specified program with fresh stack, heap

    some aspects carry over:
        same PID, PGID, SID, user, permissions, etc.
        same open files
            in particular, stdin, stdout, stderr remain open


if (fork() == 0) {
    // only in the child
    execl(...);
    // if we got here, exec failed
    perror(...);
    exit(EXIT_FAILURE);
}
// only in the parent
wait(&status);


    we don't get a lot of information from the exit status (8 bits)
    what if we could get the output from the child process?
    

int dup(int fd);
    duplicates a file descriptor
    creates a new file descriptor for an existing open file description

    both file descriptors can be used interchangeably
    both must be closed to close the file

int dup2(int oldfd, int newfd);
    duplicates a file descriptor
    the new fd will be the specified number
    if that number already describes an open file, it is closed
    
    
    int fd = open(some_file, O_WRONLY|O_TRUNC|O_CREAT, 0777);
    dup2(fd, STDOUT_FILENO);
    
        subsequently, writes to stdout will go to this file instead
        of the original stdout
        
a child process could use open and dup2 before calling exec
    the new program will get the file for stdout instead of using
    the parent's stdout


int pipe(int fd[2]);

int p[2];
pipe(p);
    on success, p will contain two file descriptors
        p[0] is the "read" end of a pipe
        p[1] is the "write" end of a pipe
        
    anything we write to the second file descriptor can be read from
    the first



int p[2];
pipe(p);   // FIXME check for failure

if (fork() == 0) { 
    // in child
    dup2(p[1], STDOUT_FILENO);
        // now stdout will write to the pipe
    close(p[0]);
    
    exec(...);
        // anything the new program writes to stdout
        // will be sent to the pipe;
        // when it terminates, the write end will be closed
}

close(p[1]);
    // note: the write end must be closed in both processes for
    // read to return EOF

// read from the pipe until EOF
while ((bytes = read(p[0], buf, BUFSIZE)) > 0) {
    ...
}

// wait for child to terminate
wait(NULL);



we can use as many pipes as we want
    e.g., one pipe for stdin, one for stdout
    
we can use this mechanism to pipe the output of one program to the
input of another


int p[2];
pipe(p);

if (fork() == 0) {
    close(p[0]);
    dup2(p[1], STDOUT_FILENO);
    exec(....)
}
if (fork() == 0) {
    close(p[1]);
    dup2(p[0], STDIN_FILENO);
    exec(...);
}
close(p[0]);
close(p[1]);
wait(NULL);
wait(NULL);

note that only two children are created


contrast with:

a = fork();
b = fork();

|
+---+
|   |
+-+ +-+
| | | |



next up: signals and multithreading

CS 214 / Signals
================

Interrupts
----------

normal CPU operation ("fetch-execute cycle")

    loop forever:
        fetch current instruction
        decode instruction
        execute instruction (and advance current instruction pointer)

interrupts break the CPU out of this cycle

    - save current state of the CPU
    - execute some other code (based on what sort of interrupt happened)
    - possibly resume what you were doing before


interrupts can happen at any time (asynchronous)

interrupts are used for:
    - preemptive multitasking
    - errors and exceptional conditions
        e.g., divide by zero, memory errors
    - arrival of input data
    - timers


Signals
-------

a way to send a message to a process asynchronously
a way for a process to indicate what should happen

several signal types
    - indicated by numbers
    - usually referred to by name


each process has a "disposition" for each signal type
    -> this says what to do when the signal arrives

for each signal type, there is a default disposition,
but processes can override it


dispositions:
    - ignore
    - terminate
    - terminate and dump core
    - stop
    - continue (a stopped process)
    - call a signal handler
        a regular function that is called when the signal arrives
        may return normally (continuing the program), exit, or jump
            somewhere else


signal types:
    man 7 signal

termination signals

SIGTERM   - default signal sent by kill command
SIGINT    - sent by terminal when user types ^C
SIGHUP    - sent when user logs out
SIGQUIT   - sent by terminal when user types a particular code
SIGABRT   - sent by abort()

SIGKILL   - sent by kill -KILL; cannot be blocked or ignored


SIGSTOP   - stops a process
SIGTSTP   - "typed stop"; sent by terminal when user types ^Z


SIGCONT   - continues a stopped process
SIGCHLD   - sent when a child process is terminated, stopped, or continued

error signals:

SIGFPE   - floating-point exception (sometimes integer div by 0)
SIGSEGV  - segmentation violation / segfault
SIGBUS   - bus error




changing disposition for a signal

#include <signal.h>

typedef void (*sighandler_t)(int);

sighandler_t signal(int signum, sighandler_t disposition);

    arguments are the signal number (use a constant) and the
        desired disposition
    returns the previous disposition
    
    special disposition values:
        SIG_IGN  - ignore
        SIG_DFL  - default
    
    it is recommended that you only use signal() with SIG_IGN or SIG_DFL



int sigaction(int signum, struct sigaction *new, struct sigaction *old);
    signum indicates the signal type
    new describes the action that we want
    old will contain the previous action
    
    struct sigaction {
        sighandler_t sa_handler;
        void (*sa_sigaction)(int, struct siginfo *, void *);
        sigset_t sa_mask;
        int sa_flags;
        ...
    }
    
    
    see man 7 sigaction for descriptions of the flags


Signal handlers
---------------

a signal handler is a function that is called asynchronously

the signal handling machinery will simulate a function call to the
handler when the signal arrives
    it gets space on top of the stack like a normal function
    if it returns, it jumps back to the instruction that was being
        executed when the signal arrives

the handler may be called at any point, including in library code
not all functions are "re-entrant"
    that is, they can't be called if they are already executing
    

you can only call functions that are signal safe/signal re-entrant

    man 7 signal-safety
    
    most C IO functions are not safe
    most system calls are safe (because they do their work in the OS)
    
general advice: do as little work in a signal handler as you can


questions to consider:
    what happens if you get a signal while you are executing a signal
        handler?


sigaction allows us to specify how to handle signals arriving during
    a signal handler
    - we can temporarily install a different handler 
    - we can temporarily block that signal (or others)
    - we can do nothing and see what happens


a process has a "signal mask" that indicates which signals are "blocked"

if we block a signal, any signals of that type are held in a queue
they get delivered when the signal is unblocked

use sigprocmask() to change the process's signal mask

sending signals
---------------

kill command sends signals to processes

    kill [-NAME] PID
    
        if we don't give a name, it sends SIGTERM
        

int kill(pid_t pid, int signum);

    sends a signal to the specified process
    
int raise(int signum);

    sends a signal to the current process
    
    

CS 214 / Multithreading
=======================

Threading
---------

"tasks" - fetch-execute cycle
    - instruction pointer, usually a stack
    - can run concurrently, execute different programs


"process" - OS abstraction
    - one (or more) tasks
    - private virtual memory

multitasking - can run more than one task concurrently
multiprocessing - multiple processors, each executing a task


we can use processes for multitasking, but it can be inconvenient
communication is limited between processes
    - signals
    - read/write pipes
    - send data through file system
    
    
multithreading - more than one task in a single process
    "thread" - a task running in a multithreaded process
    
    threads in a process share the same virtual memory
    - shared memory greatly eases communication among tasks
    - coordination needed to avoid problems
        - violation of data structure invariants
        - nondeterministic behavior
        - "impossible" behavior

2 major kinds of multithreading systems

"OS threads"/"kernel threads"
    - rely on OS task scheduler
    - visible to OS
    - OS can schedule threads on different CPUs

"green threads"/"library threads"/"language threads"
    - created and managed by language run-time system
    - not visible to OS
    - usually lower overhead than kernel threads
    - can take advantage of language-specific information



Need for synchronization
------------------------

race condition 
    - outcome of program depends on which thread finishes first
    - behavior depends on scheduler
    
    
    Thread A        Thread B
    --------        --------
    X = 1           X = 2

After both threads have executed, what is the value of X?
    X will be either 1 or 2, depending on how the threads were scheduled
    instead of a single outcome, we have a set of possible outcomes
    

    Thread A        Thread B
    --------        --------
    X++;            X++;
    
X is initially 0. After both threads finish, what is X?
    it could be 1 or 2, since the increment may not be atomic


data race
    - occurs when multiple threads have unsynchronized access to
        a piece of data, and at least one thread writes
        
        
the behavior of C programs containing data races is undefined


    Thread A                            Thread B
    --------                            --------
    for (i = 0; i < 100; i++) {         X = 0;
        X = 1;
        A[i] = X;
    }

101 possible behaviors
    A is all 1
    A is all 1, except a single 0
    
    Thread A (optimized)
    --------------------
    X = 1;
    for (i = 0; i < 100; i++) {
        A[i] = X;
    }

101 possible behaviors
    A is all 1
    A is zero or more 1s followed by 0s
        -- 99 of these behaviors are new!
        
this optimization changes the possible behaviors, because of the data race
we want to allow this optimization, so instead we forbid data races


by synchronizing access to shared data, we eliminate data races



Tools for synchronization
-------------------------

memory fence
    instruction that pauses the current task until all its pending
    writes have completed
    
    hard to use optimally
    - too many fences slows your program
    - not using fences in the right places allows data races

    typically, memory fences are best left to experts
    library code will have the fences where they are needed/helpful

mutual exclusion / "mutex" / "locks"
    enforce sequential access to shared resources
    operations: lock and unlock
        one thread can "hold" the mutex at a time
        a thread trying to lock a locked mutex will block until the
            mutex is unlocked


let's write a lock

int lock = 0;  // shared across threads

operation:
    // acquire lock
    while (lock != 0) { // do nothing }
    lock = 1;
    
    // do stuff (critical section)
    
    // release lock
    lock = 0;
    
but the acquisition part doesn't provide safety
    another thread could execute between the loop and the assignment!
    problem is that the check and the assignment are not atomic
    
hardware must provide an atomic operation
    test-and-set
    compare-and-swap
    fetch-and-add

we can imagine test-and-set as a function that sets a variable to 1
and returns its previous value, atomically

    while (test_and_set(&lock) != 0) { // spin }
    
    // do stuff (critical section)
    
    lock = 0;


CS 214 / pthread
================

recap:
    a multithread process contains multiple tasks with a single virtual
        memory (containing program code, globals, the heap, etc.)


race condition -
    outcome depends on how tasks are scheduled;
    may or may not be a problem

data races - 
    multiple threads have simultaneous access to some data, and at least
    one is writing
    - never good


making threads
--------------

pthreads - Posix threads
    general interface for creating threads
    provides several primitives for synchronizing threads


when using pthreads with GCC, compile with -pthread

#include <pthread.h>

int pthread_create(
    pthread_t *thread_id,
    pthread_attr_t *attributes,
    void *(*start_function)(void *),
    void *argument);


essentially calls a function "in the background"

on success,
    create a new thread that executes start_function(argument)
    
    a thread identifier is written to thread_id
    returns 0
    
on failure, returns an error code (does not write to errno)

pthread_t may be an integer or a structure
    it can be passed to functions, but should be treated as an opaque value
    use pthread_equal() rather than ==


pthread_attr_t is an abstract struct describing thread features

    pthread_attr_init(pthread_attr_t *attrs);
    pthread_attr_destroy(pthread_attr_t *attrs);
    
    multiple functions named pthread_attr_get<something>() and
        pthread_attr_set<something>()
        
we can just pass NULL to get default settings for threads




the function takes a single void pointer and returns a void pointer

void *thread_worker(void *arg);



int pthread_join(pthread_t thread_id, void **return_value);

    if the specified thread is still running, block until it terminates
    otherwise, obtain its return value from the thread table
    write the value it returned to *return_value
    
        (pass NULL to drop any returned value)

    note that we specify which thread we are joining with
    -> otherwise, we would have no way to know what sort of pointer we
        would get

example: calling a function in the background and obtaining its result
    once we are ready for it
    
    
    {
        pthread_t worker;
        arg_t arg = ...;
        rval_t *rval;
        
        pthread_create(&worker, NULL, background_work, &arg);
            // need to be sure background_work() wants a pointer to
            // an arg_t
    
        // do our own work for a while
        
        pthread_join(worker, &rval);
            // once this returns, we know background_work() has finished

            // rval now contains its return value   
    
    }


a more common pattern is to spawn multiple threads, each taking
a portion of a larger task, and then waiting for them all to finish


    {
        pthread_t workers[5];
        int args[5];
        
        for (int i = 0; i < 5; i++) {
            args[i] = i;
            pthread_create(&workers[i], NULL, worker_function, &args[i]);
            
            //pthread_create(&workers[i], NULL, worker_function, &i);
        }
        
        // now all five threads have been created
        
        for (int i = 0; i < 5; i++) {
            pthread_join(workers[i], NULL);
        }
        
        // once we get here, we know all the threads have completed
    
    }

processes           threads
---------           -------
pid_t               pthread_t
fork()/exec()       pthread_create()
wait()/waitpid()    pthread_join()
exit()              pthread_exit()


processes have a defined parent/child relationship
    every process has a parent, only its parent can wait for it

threads are peers
    any thread can join any other thread
    "detached" threads cannot be joined



void pthread_exit(void *rval);
    // terminates current thread




a few other thread functions that might possibly be useful

pthread_t pthread_self();
    returns identifier of current thread

int pthread_equal(pthread_t t1, pthread_t t2);
    tests whether two thread identifiers are equal
    
int pthread_kill(pthread_t thread, int sig);
    sends a signal to the specified thread
    
int pthread_cancel(pthread_t thread);
    tells a thread to terminate
    
int pthread_detach(pthread_t thread);
    makes a thread unjoinable
    thread will clean itself out of the thread table when it terminates


sequentializing access
----------------------


pthread_mutex_t - abstract structure
    provides a mutex ("lock")
    
    
locks must be initialized and destroyed

    int pthread_mutex_init(pthread_mutex_t *lock, pthread_mutexattr_t *attrs);
    
    int pthread_mutex_destroy(pthread_mutex_t *lock);
    
    
locking and unlocking

    int pthread_mutex_lock(pthread_mutex_t *lock);
    int pthread_mutex_unlock(pthread_mutex_t *lock);


at most one thread can "have" the lock at a time
    calling lock() will block if another thread holds the lock
only the thread that has the lock can call unlock()


usual pattern:

    pthread_mutex_lock(&m);
    
        // critical section
        
    pthread_mutex_unlock(&m);



typedef struct {
    int balance;
    pthread_mutex_t lock;
} account_t;
    // invariant: balance is only accessed while holding lock


void account_change(account_t *a, int difference)
{
    pthread_mutex_lock(&a->lock);
    
    a->balance += difference;
    
    pthread_mutex_unlock(&a->lock);
}

by limiting access to balance to synchronized code, we eliminate data races




void account_transfer(account_t *dest, account_t *src, int amount)
{
    account_change(src, -amount);
    account_change(dest, amount);
}

CS 214 / Condition variables
============================

mutex - abstraction used to coordinate exclusive access to resources
    "locked"   - exactly one thread has access
    "unlocked" - no thread has access
    
    a thread trying to lock a locked mutex will block, until the
        thread that locked the mutex unlocks it
        
    only the thread that locked the mutex can unlock it
    

using mutex, we can arrange sequential access to shared data structures

    "can arrange", not "enforce"
        you have to play by the rules to get safety



example: thread-safe queue

    enqueue
    dequeue
    
        -> what should happen if we dequeue from an empty queue?
        we could report that the queue is empty
            -> but it may not stay empty
        
        we don't want to keep trying to dequeue hoping for success
            "busy waiting"
            increases contention of the mutex
            
        we could wait for another thread
            but how long?
            
condition variable - allows a thread to block until something happens
    normally associated with a (specific) mutex
    while the thread is blocked, it unlocks the mutex
    when the thread proceeds, it relocks the mutex


pthread_cond_t - abstract condition variable type

int pthread_cond_init(pthread_cond_t *cv, pthread_condattr_t *attr);
int pthread_cond_destroy(pthread_cond_t *cv);


int pthread_cond_wait(pthread_cond_t *cv, pthread_mutex_t *lock);
    blocks current thread and releases lock
    reacquire the lock when resuming

int pthread_cond_signal(pthread_cond_t *cv);
    wakes one thread currently waiting for cv

int pthread_cond_broadcast(pthread_cond_t *cv);
    wakes all threads currently waiting for cv

    "spurious wakeup"

C1                  P1                      C2
dequeue
-> wait for
    read_ready

                    enqueue
                    ->signal
                        read_ready
unblocks
                                            dequeue
                                            -> length = 0

regain lock
-> queue empty!



engineering tradeoffs:
    how many mutexes do we need?
    what should be exclusive?
    
    too few mutexes can increase contention
        -> less ability for threads to run concurrently
    
    too many mutexes may lead to unsafety
        -> deadlock
        -> not actually guaranteeing sequential access (data races!)
        -> lots of time locking and unlocking



reasoning about sequential data structures can be hard!
    need to consider many worst-case scenarios
    anything that can possibly go wrong will go wrong


CS 214 / Deadlock, semaphores
=============================

key idea: coordinate exclusive access to shared mutable resource

key challenge: determining what needs to be sequential
	if too many things are sequential, you lose concurrency
	if not enough things are sequential, we can have data races

one solution: mutual exclusion
	using a mutex, we can coordinate exclusive access to a resource
		at most one thread has access at a time
		every access is strictly before or after every other access

questions:
	how many mutexes should we have
	what code should be in the critical sections (when we have exclusive access)
	
		not enough mutexes leads to too many things being sequential
		too many mutexes are difficult to understand
			-> possible non-exclusive behavior		


deadlock
--------

	typedef struct {
		int balance;
		pthread_mutex_t lock;
	} account_t;
	
	
	void transfer(account_t *dst, account_t *src, int amount)
	{
		pthread_mutex_lock(&src->lock);
		pthread_mutex_lock(&dst->lock);
		
		src->balance -= amount;
		dst->balance += amount;
		
		pthread_mutex_unlock(&dst->lock);
		pthread_mutex_unlock(&src->lock);
	}

	account_t X, Y;

	thread A			thread B
	--------			---------
	
	transfer(Y, X, a);	transfer(X, Y, b);
	lock(X)				lock(Y)
		-> acquired			-> acquired
	lock(Y)				lock(X)
		-> blocked			-> block
		
	A can't proceed until B finishes
	but B can't proceed until A finishes


necessary conditions for deadlock
1. mutual exclusion
2. hold-and-wait
	while holding exclusive access to one resource, block trying to get
	access to another
3. no preemption
	no thread can force another thread to release exclusive access
4. circular wait
	e.g. A waits for B and B waits for A


possible solutions:
disallow hold-and-wait
	e.g., only allow one lock at a time
	e.g., if we need multiple locks, get them all simultaneously
		you either hold all the locks, or block until they are all available
		
disallow circular wait
	always acquire multiple locks in some specified order
	(may not always be practical)



we can design higher-order interfaces involving multiple locks
	that ensure deadlock cannot happen
	-> "monitors"



barriers
--------

https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_barrier_init.html

abtraction used to create "rendezvous" points
	points where all involved threads are at known locations
	

pthread_barrier_t

int pthread_barrier_init(pthread_barrier_t *bar,
	pthread_barrierattr_t *attr,
	unsigned int count);

int pthread_barrier_destroy(pthread_barrier_t *bar);

int pthread_barrier_wait(pthread_barrier_t *bar);
	blocks threads until the specified number of threads are waiting
	
	
	for (...) {
		// concurrent stuff
		
		pthread_barrier_wait(&bar);
	}


semaphores
----------

first synchronization primitive
most powerful synchronization primitive

idea: integer that can be increased or decreased
	but cannot be decreased below zero
	
can be used to model a limited number of available resources
	
operations:
	#include <semaphore.h>
	
	sem_t
	int sem_init(sem_t *sem, int pshared, unsigned int count);
	int sem_destroy(sem_t *sem);
	
	int sem_post(sem_t *sem);  // increments the integer (maybe wakes a thread)
	int sem_wait(sem_t *sem);  // decrements the integer (maybe blocks)

we can make a mutex using a semaphore

	mutex			semaphore
	-----
	init()			init(1)
	"locked"		0
	"unlocked"		1
	lock()			wait()
	unlock()		post()
	
	
	
we can make something like a condition variable with a semaphore

	cond.var		semaphore
	--------		---------
	init()			init(0)
	wait()			wait()
	signal()		post()
	
	except: calling signal() when no thread is waiting has no effect
		but calling post() always increments the integer

The Little Book of Semaphores
	excellent tutorial for using semaphores to write multithreaded programs



typedef struct {
	data_t *data;
	int first;
	int last;
	int size;
	sem_t lock;			// used for mutual exclusion
	sem_t open;			// represents unused space in the array
	sem_t occupied;		// represents items in the array
} queue_t;

void q_init(queue_t *q, int capacity)
{
	q->data = malloc(sizeof(data_t) * capacity);
	q->size = capacity;
	q->first = 0;
	q->last = 0;
	sem_init(&q->lock, 0, 1);        // mutex initially unlocked
	sem_init(&q->open, 0, capacity); // all spaces initially open
	sem_init(&q->occupied, 0, 0);    // no spaces initially occupied
}


void q_enqueue(queue_t *q, data_t item)
{
	sem_wait(&q->open);
	
	sem_wait(&q->lock);
		q->data[q->last] = item;
		q->last++;
		if (q->last == q->size) q->last = 0;
	sem_post(&q->lock);

	sem_post(&q->occupied);
}

void q_dequeue(queue_t *q, data_t *dst)
{
	sem_wait(&q->occupied);
	
	sem_wait(&q->lock);
		*dst = q->data[q->first];
		q->first++;
		if (q->first == q->size) q->first = 0;
	sem_post(&q->lock);

	sem_post(&q->open);
}


major differences with semaphores

	in general, any thread can call post on any semaphore
	
Posix-specific differences

	semaphores can be used in signal handlers
	
	semaphores can be external to a process and shared among processes
	
		sem_open()

CS 214 / Multithreading examples
================================

late submissions for project III will be accepted until next Monday

reminder: late submissions lose 10 points per day (rounded up)
    late penalties will not reduce your score below 60

Project IV is cancelled
    - instead, some exercises you can work on by yourself
    - the project will be repurposed for in-class examples

Final exam will be on-line via Canvas
    24-hour window
    primarily multiple choice


exercise: read/write lock
-------------------------

idea: we allow two kinds of access to a resource
    write access (exclusive)
    read access (non-exclusive)
    
operations
    init/destroy
    
    read_lock
        increases the number of threads with read access
        blocks if any thread has write access

    read_unlock
        decreases the number of threads with read access

    write_lock
        increases the number of threads with write access
        blocks if any thread has read or write access
        
    write_unlock
        decreases the number of threads with write access


data to track in your lock structure
    what sort of access is currently held
    how many threads have read access
    how many threads are waiting for write access
    a mutex and condition variables; or semaphores
    


starvation
----------

starvation occurs when a process is unable to acquire a resource, because
other processes keep acquiring it first

e.g., in a simple design for a read/write lock, reading threads can
    starve a writing thread
    
one solution: force some sort of turn-taking
    e.g., if a thread is waiting for write access, threads cannot acquire
        read access until the writer has had its turn


livelock
--------

two or more processes have incompatible prerequisites
    each process changes state for its own needs
    other processes undo these changes for their needs
    
    
    thread A            thread B
    --------            --------
    while X != 1        while X != 0
        X = 1               X = 0
    do stuff            do stuff
    
    


another thread-safe queue
-------------------------

scenario: multithreaded recursive directory traversal

idea:
    have a pool of directories to traverse
    each thread repeatedly:
        1. obtains a directory from the pool
        2. reads the entries in the directory
        3. adds any subdirectories to the pool
        4. continues until all directories have been traversed

    advantages of this approach:
        fixed number of threads
        finite number of directories open simultaneously
        even distribution of work among threads
        
questions to consider
    - can we use a bounded queue?
        no: this can deadlock if the queue is full
        
    - how do we know when we are finished?
        the pool is empty and all the threads are waiting for the pool
        (but if any thread is waiting the pool must be empty)
        
        
    typedef struct {
        char **paths;  // names of directories to traverse
        int itemcount;  // number of paths in the pool
        int arraysize;  // length of array
        int active;     // number of non-blocked threads
        pthread_mutex_t lock;
        pthread_cond_t nonempty;
    } pool_t;
    
    void pool_init(pool_t *p, int capacity, int threads)
    {
        ...
        p->active = threads;
        ...
    }
    
    void pool_add(pool_t *p, char *path)
    {
        pthread_mutex_lock(&p->lock);
        
        if (p->itemcount == p->arraysize) {
            p->arraysize *= 2;
            p->paths = realloc(p->paths, p->arraysize * sizeof(char *));
        }
        
        p->paths[p->itemcount] = path;
        p->itemcount++;
        
        pthread_cond_signal(&p->nonempty);
        
        pthread_mutex_unlock(&p->lock);
    }
    
    // return 1 on success, 0 on failure
    // on success, write the removed item to dst
    int pool_remove(pool_t *p, char **dst)
    {
        pthread_mutex_lock(&p->lock);
        
        if (p->itemcount == 0) {
            p->active--;
            
            if (p->active == 0) {
                pthread_cond_broadcast(&p->nonempty);
                pthread_mutex_unlock(&p->lock);
                return 0;
            }
            
            do {
                pthread_cond_wait(&p->nonempty, &p->lock);
                if (p->active == 0 && p->itemcount == 0) {
                    pthread_mutex_unlock(&p->lock);
                    return 0;
                }
            } while (p->itemcount == 0);
            
            p->active++;
        }
        
        p->itemcount--;
        *dst = p->paths[p->itemcount];
        
        pthread_mutex_unlock(&p->lock);
        
        return 1;
    }




int wstatus;

finished_child = wait(&wstatus);

success = WIFEXITED(wstatus) && WEXITSTATUS(wstatus) == 0;

CS 214 / Network communication
==============================

what do we mean by network communication?
    - sending messages from one computer to another
    - more precisely: from a process on one computer to a process
        on a different computer


What is needed for network communication?
    protocol: what sorts of messages can we send?
        how are they expressed?
        when are they sent and by whom?
    
    addressing: how do we indicate the participants?



layers from the ground up:

how do I communicate between two computers?

one answer: connect a wire between them

two or more connected devices are called a "link"

to add more than two hosts, we can add special devices
    hub - in Ethernet, a device with a certain number of ports (e.g., 4)
        we run a wire from each host to a port on the hub
        the hub forwards any messages it receives to every other host
    
    -> in Ethernet, every message frame includes a destination address
        every Ethernet device has a unique address (MAC)
        when a device receives a message for a different MAC, it ignores
            the message
            
    because hubs simply forward frames, they are very simple
        -> fast and inexpensive
    but forwarding every frame to every participant uses a lot of
        network resources
    
    
    switch - similar to a hub, but it associates MACs with ports
        messages are only forwarded to the port associated with the
            destination
        
        because the switch has to examine messages and keep track of
            MACs, it is slower and more expensive than a hub

typically, a link involves devices controlled by a single organization
-> not especially secure
-> every device can talk to any other device
-> little privacy

Ethernet also describes
    how are messages sent?
        large messages are broken into smaller parts
        each part is made into a "frame"
        the frame also includes the destination address
    
    how is network time divided?
        in the event two devices try to send at the same time, both
        will wait a random amount of time and retransmit
        -> this works well in practice!




internetworking - communication between devices on different networks

idea: our link contains one or more devices called "routers" or
    "border routers"
    
    a router connects two networks
    
Internet Protocol (IP)
    hosts are identified by IP address
        in IPv4 - 32-bit integer
            commonly written in "dotted quad"
            e.g., 127.0.0.1
        
        in IPv6 - 128-bit integer
            commonly written as groups of four hex digits separated by
            colons

    messages are broken into "packets"
        each packet indicates its source and destination IP addresses
        packets are sent separately across the network
        routers receiving a packet will transmit it to a peer hopefully
            getting it closer to its destination
            
        IP is a "best effort" protocol
            packets may be lost
            packets may be received out of order

    each router has a routing table
        -> given an IP address, which outgoing port should this packet
            be sent to?

    to keep the routing table simple, addresses are grouped into "subnets"
    typically, addresses with a similar prefix are part of the same
        subnet, and so one entry in the table can handle all of them
    
    early internet used three "classes" of subnets
        class A uses 8-bit prefix
        class B uses 16-bit prefix
        class C uses 24-bit prefix
        
    modern IPv4 uses "classless" routing where subnet prefixes can be any
        length
        
        often indicated with a slash and a number
        208.13.128.0/9  - indicates a subnet with a 9-bit prefix

    routers have their own protocols to send updated routing information


CS 214 / Sockets
================

Network stack
    link layer - communication between machines on the same network
        Ethernet - communicates in discrete messages (frames)
    
    Internet layer (IP) - communication between machines on the Internet
        packet forwarding, best-effort
            messages are broken into individual packets, each sent
            separately
            messages can be lost, or arrive out of order
        
        IP packets are roughly 20 - 65,000 bytes
            packets that are too large for the underlying transport
            are "fragmented" and reassembled at the recipient
            1500 bytes is a common size
    
        endpoints are identified by IP address
            - identifies a network interface (usually 1 per machine)
    
    Transport layer
        UDP (User Datagram Protocol)
            send individual messages from one service to another
            endpoints identified by IP address and port number

            best effort, datagram protocol
            non-connection oriented
            
        TCP (transmission control protocol)
            read and write byte streams sent between two services
            endpoints identified by IP address and port number
            
            connection oriented
            TCP itself makes sure that bytes are received in order
            TCP divides the outgoing byte stream into "segments"
                (each segment is sent in a single packet)
                
            from an application standpoint, most of the work is done
            by the OS
            

sockets
-------

a set of functions used to establish network communication
part of POSIX

fundamental type: the socket
    this is a file descriptor that refers to a network service
    
functions attempt to be as general as possible
    does not assume we are using a particular network
    does not assume we are working at a particular level


int socket(int domain, int type, int protocol);

    domain - what sort of network will we be using (AF_INET)
    type - what sort of socket are we creating
        SOCK_STREAM  - communication via streams (e.g. TCP)
        SOCK_DGRAM   - communication via datagrams (e.g., UDP)
        various others used by other network types
    
    protocol - used to distinguish between multiple transports of the 
        same type (typically 0)

    returns a file descriptor on success
    returns -1 on failure
    
    this creates an abstract socket, but does not configure it
    
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);

    for streaming sockets, establish a connection with a service on
    a remote host
    
    sockfd  - file descriptor returned from socket()
    addr    - address of the remote service
    addrlen - length of the addr struct
    
    note: addresses are usually network-specific structures
        we cast the pointer to struct sockaddr * and provide the size
        
        usually we don't create this struct ourselves


domain name service (DNS)
-------------------------

DNS a distributed hierarchical database that stores information about
    "domains"
    
    domains are identified by words separated by periods
    
        rutgers.edu
        google.com
        amazon.co.uk
        cs.rutgers.edu
        www.cs.rutgers.edu
        
        subdomains add additional words to the front of the name
        
    each domain is controlled by some organization, which can establish
        subdomains with their own owners
        
    
    each domain can have several kinds of information
        e.g., who controls the domain & how to reach them
        
        A - associates an IPv4 address with this domain
        AAAA - associates an IPv6 address with this domain
        MX - indicates the machine used for mail handling
        
for many protocols, we look up the IP address for a domain and use that
to connect (or send datagrams)


data is stored hierarchically, similar to directories in the file system

    edu says where to find rutgers.edu
    rutgers.edu says where to find cs.rutgers.edu
    cs.rutgers.edu says where to find wax.cs.rutgers.edu
    
typically, you will have a local DNS server that caches results from
past DNS queries

the Unix commands host and dig perform DNS queries and print the results


typically, your local internet configuration will specify a DNS server
used for queries


using DNS to get addresses
--------------------------

the old way: gethostbyname()

the better way:

int getaddrinfo(
    const char *node,             // e.g., domain name
    const char *service,          // e.g., service name or port number
    const struct addrinfo *hints, // used to narrow down results
    struct addrinfo **res);       // will point to first entry in a linked
                                  // list of answers
             
             
    returns 0 on success
    an error code on failure
        (not compatible with errno, perror(), etc.)
        (use gai_strerror() to get a description of the error)

struct addrinfo {
   int              ai_flags;
   int              ai_family;    // domain argument to socket()
   int              ai_socktype;  // type argument to socket()
   int              ai_protocol;  // protocol argument to socket()
   socklen_t        ai_addrlen;
   struct sockaddr *ai_addr;      // addr argument to connect()
   char            *ai_canonname;
   struct addrinfo *ai_next;
};


see network.c for examples of using getaddrinfo() with socket() and connect()


usual pattern for clients:
    use getaddrinfo() to get a linked list of address information records
    use these with socket() and connect() to establish a connection
    
client-server pattern:
    client creates connections (active)
    server waits for clients to request connections (passive)
    
establishing a listening socket requires three functions

int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);

    tells network system to associate our socket with a specific port
    on the local host
    
    sockfd - obtained from socket()
    addr - identifies the port (recommended: obtain from getaddrinfo())
    
    returns 0 on success, -1 on failure (sets errno)
    
int listen(int sockfd, int backlog);

    tells network system that we want to wait for incoming connection
    requests
    
    sockfd - obtained from socket()
    backlog - determines size of connection request queue
    
    returns 0 on success, -1 on failure (sets errno)
    

int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);

    obtain file descriptor for an incoming connection request
    (block until one arrives, if none have arrived yet)
    
    sockfd - listening socket
    addr - address of remote host will be written here
            (use NULL if we don't care)
            
    returns a new streaming socket specific to this connection
    returns -1 on failure (sets errno)
    
each time we accept a connection request, we get a new socket





    





CS 214 / Server structure
=========================

Recap: establishing TCP connections

two sides: 
    - listener waits for connection requests
    - active side requests connection from listener
    
incoming packets are associated with a particular connection by looking at
    - sender host:port
    - recipient host:port
    
examples:
    three machines: A (listener), B and C connect to A
        A listens for connection requests on port 15000
        B and C can use any port numbers on their side (maybe the both use 100)
        
        A-B : to A:15000, from B:100
        A-C : to A:15000, from C:100
        
    because the sender addresses are different, A can tell which packet
    goes with which connection
    
    two machines: A (listener), B connects to A twice
        A listens for connection requests on port 15000
        first B connection uses port 100
        second B connection uses port 101
        
        first connection: to A:15000, from B:100
        second conection: to A:15000, from B:101
        
establishing a connection to an existing listener

recommended: getaddrinfo()
    - works with IPv4 and IPv6 without writing protocol-specific code
    - avoid worrying about network byte order
    

    socket() - gives us a file descriptor to use
    connect() - establishes connection to remote host (listener)
        
    read() - receive bytes from remote host
    write() - send bytes to remote host
    
    socket-specific variants: recv() and send()
    for datagrams: recvfrom() and sendto()
        (but we would not use connect())

    close() - closes both streams
    shutdown() - closes one stream
    
    
establishing a port listening for incoming connection requests

recommended: getaddrinfo()
    - allows us to work with IPv4 and IPv6 transparently
    - in our hints, include the flag AI_PASSIVE
    - use NULL for the node (indicates we want a port on our machine)
    
    socket() - gives us a file descriptor for listening
    bind()   - associates the socket with a specific port
    listen() - tells network stack we will be waiting for connection requests
    
    
    accept() - receives incoming connection requests
        - blocks until request received
        - returns a new socket for that connection
      
        

server strategies
-----------------

"one at a time"

repeat forever:
    accept incoming connection
    communicate with client
    close connection
    

- very simple (no concurrency)
- can only handle one client at a time (no concurrency)


multiple processes

repeat forever:
    accept incoming connection
    fork
        in child: communicate with client, then terminate
    close connection

- multiple concurrent connections
- one process per connection
    - one process crashing does not affect other processes
    - communication can be cumbersome

- problem: dealing with zombies
    - calling wait() before accept() means we can't get a new connection
      until the last one ended - but this is just one at a time again
      
    - one possibility: install a handler for SIGCHLD that reaps the child
        use the 3-argument signal handler form to get PID of terminated child
        use waitpid() to reap that specific process
        - good if we want to get exit status from children

    - other possibility: set disposition for SIGCHILD to SIG_IGN
        this prevents child processes from becoming zombies
        (they disappear from the process table as soon as they terminate)


multiple threads

repeat forever:
    accept incoming connection
    spawn thread to deal with client
    detach thread
    

- multiple concurrent connections
    - each thread handles its own connection state
- simpler communication between threads
- one thread can crash the entire process

may have to think about signals
    problem: in a multithreaded process, signals can be handled by any
        thread chosen at random
    - unless we use signal masks to limit which threads can receive the
        signal
        
    solution: have main thread unblock e.g. SIGINT, but all other
        threads block SIGINT
        - this means the main thread will receive any SIGINT signals


multiplexing
allows concurrent connections with fewer threads than connections
poll() or select()

CS 214 / Application example
============================

Schedule
    Monday, April 29: review for final exam
    Monday, May 6: final exam
        - comprehensive
        - on-line via Canvas
        - available for 24 hours
        - primarily multiple choice


the ghost of project IV
-----------------------

on-line video game server
    for rock-paper-scissors


assume these:
    Physical layer
    Data link layer
    Network layer (IP)
    Transport layer (TCP)
    
we need to design
    Session layer
    Presentation layer
    Application layer
    
    

session choices
---------------


choice: peer to peer vs client-server vs other

    for us, client-server makes sense
        client corresponds to a player
            - establishes connection
            - provides UI
            
        server manages game sessions
            - waits for connection requests
            - pairs clients into game sessions
            - adjudicates victory
            

application choices
-------------------

what kinds of messages do we need?
who should send those messages?
what does the message flow look like?


game messages:
    server tells clients to move
    clients report their moves
    server indicates the results
    clients decide whether to keep playing
    
setup messages:
    connection message from client
        - can have parameters such as protocol version,
            preferred game type, player name, etc.
            
    response from server
        - indicates whether the parameters are acceptable
        
        
example flow:

    Client          Server
    connect()       accept()
        -- PLAY ->
        <- WAIT --
        
        <- BEGIN --
        -- MOVE ->
        <- RESULT --
        -- QUIT/CONTINUE ->
        
possible errors
    - incomplete or garbled messages
    - sending inappropriate messages
    - unexpected closing of connection
    
dealing with errors
    - close connection
    - send error message and close connection
    - send error message and try to continue
    


Presentation
------------

for today, we will make presentation very simple
    all messages are one byte
    
    (this is a proof-of-concept, rough draft protocol. for now.)
    


PLAY            H
WAIT            A
BEGIN           B
MOVE
    ROCK        R
    PAPER       P
    SCISSORS    S
RESULT
    WIN         W
    LOSS        L
    DRAW        D
    FORFEIT     F
CONTINUE        C
QUIT            Q

A real protocol would want longer messages so that we could include
more information
    e.g. player names, preferred games, other player's moves


writing a server
----------------

for initial testing, we want a test client
    - probably fairly simple, until the server is more complete
    
    
structure: dealing with multiple game sessions
    - no concurrent game sessions
    - single thread that handles everything
    - one thread per connection (=> two threads per game session)
    - one thread per session (=> two connections per thread)
    
    (alternatives: use processes instead of threads)
    

    
    
    
        
    


CS 214 / Protocol consideration
===============================

we introduced our example: rpsd
    rpsd = rock-paper-scissors daemon
        "daemon" - traditional Unix term for a server

rock-paper-scissors protocol

    we assume TCP/IP for transport
    
    session layer
        - which party establishes connections
        - how long are connections maintained / who closes connections
        
    presentation layer
        - format of messages as byte streams
        
    application layer
        - what messages can be sent
        - when and from whom these messages can be sent
        


    on Monday, we deliberately chose a very simple presentation
        (one-byte messages)


error conditions in network communication

    - unexpected end of connection
    - invalid message / garbage data
    - inappropriate message


there is no way to deal with these that is correct for all situations
    and applications
    
e.g., if we get an invalid message, the most reasonable thing to do
    may be to close the connection
    
    - we might want to request a retransmission, but how can we tell
        when the "good" portion of the data stream starts?
        

if messages can be more than one byte, we need to consider
    - incomplete messages
    
    
one simple solution to incomplete messages: call read() again

but: what if we want more control over when we block?

    -> we may not want to block indefinitely
        it's possible that the other side thinks it sent a complete message
        and is waiting for our response
        
    a protocol may require that a message arrive completely within
    some time window (e.g., 500 ms from the first byte arriving)
        we can use setsockopt() to put a timeout on every call to read()
        we can use poll() to block until data arrives or time expires
        we could use another thread to interrupt the blocked call to read()
        

-> we may be waiting for multiple possible events
    e.g., data could arrive on more than one socket, in any order
    
    
        read(sock1, ...);
        read(sock2, ...);
            <- can't receive data from sock2 until data from sock1 arrives
            
        accept(listener, ...)
        ...
        read(socket, ...)
            <- can't accept connections until this read() returns
        
    we can use poll() to avoid these problem areas
        poll() can wait for multiple events
        when any of these events happens, it indicates which one(s)
        
    we can use multiple threads, each waiting for one event
        may require some coordination between threads (pthreads)
        
example scenario:
    in our protocol: after a game, both parties indicate whether they
        want to continue
        
    what if player A wants to continue, but player B wants to quit?
        (our design says the game session ends once one player quits)
        
    with a single thread, this is easy:
        as soon as we see the QUIT from B, we can close both connections
        and terminate
        
    if we have one thread per connection, thread A will have called
    read() again (and blocked) before the QUIT from B arrives
        -> we can still interrupt a blocked system call using signals
        
        pthread_kill() lets us send signals to specific threads
        we can use signals such as SIGUSR1 that won't be sent by the OS
        
        
recap:
    we will often want to wait for one of multiple events to occur
    system calls like accept() or read() can only wait for one event
    
    poll() lets us wait for multiple events (relating to file descriptors
        or timeouts)
    
    multiple threads also allow us to wait for multiple events,
        including signals from other threads



multi-byte messages
-------------------

    consider this scenario
    
        recv_msg(&s1, &m1);
        recv_msg(&s2, &m2);
            <- can't receive message from s2 until after s1
            
            
        do {
            poll({s1, s2})
            if (data arrived on s1) recv_msg(s1, m1)        
            if (data arrived on s2) recv_msg(s2, m2)
        } until we got both messages
            <- if recv_msg doesn't block, this is maximally responsive
            <- problem if s1 sends two messages
            
    one approach:
        split recv_msg() into two functions
        
        refresh_handle() receives incoming data and stores it in a buffer
        parse_msg() determines whether the buffer contains a message
        
        
    do {
        check for message from s1
        check for message from s2
        if < 2 messages:
            poll()
            call refresh handle on the socket that got data
            (unless it already has a message waiting)
    } until 2 messages
        
        
multi-byte message formatting
-----------------------------

TCP gives us a stream of incoming bytes
how can we tell where one message ends and the next begins?

-> common mistake: assume each call to read() will obtain one message
    this is often the case! (but not always)
    
our format needs to indicate where messages begin and end

- fixed-length messages
- delimited messages
    some byte sequence that indicates the end of a message
- explicit length field
    indicate how many more bytes are coming
- explicit length fiend and delimiter
    more confidence that message has ended
    but now we have to deal with what happens when they disagree
    
    
revised RPSP

    PLAY <player name>
        P|<name>||
        
    WAIT
        W
        
    BEGIN <opponent name>
        B|<name>||
        
    MOVE <move>
        M|<move>||
        
    RESULT <condition> <opponent's move>
        R|<W/L/D/F>|<move>||
    
    CONTINUE
        C
    
    QUIT
        Q

CS 214 / Review
===============

Final Exam: Monday, May 6
	On-line via Canvas
	Available for 24 hours
	Exam itself will be approx. 1.5 hours total

C programming
-------------

C syntax

types
    - integer types 
    - floating point
    - enums
    - structs
    - unions
    - arrays
    - pointers
    
C pointers
    address of data (run-time)
    type (compile-time)

    pointer types are used to generate appropriate code, but are
    forgotten after compilation
        given a pointer, there is no way to query what sort of data
        it refers to
        
    "void" pointers have no type information
        - they must be cast to a specific pointer type to be used
        - or we can use generic operations such as memcpy() 
            - but only if we know the size of the data

        - to use properly, we need to know (as programmers) what sort
          of data we are using, even if it is not expressed in the types

memory allocation/deallocation
    malloc() / calloc() / realloc() - reserve space on the heap
        the run-time system maintains some sort of data structure that
        tracks which portions of the heap are allocated or free
    
    free() - deallocates a previously allocated heap object

object vs data

    object - location in memory that can hold data
    value  - actual bytes stored in an object at some point in time
    
    an address identifies an object
    
    a pointer variable has an object that stores the address of
        another object
        
        &p  - address of the pointer variable itself
        p   - value of the pointer, address of the object it points to
        *p  - value of the object it points to
        
        int I[2];
        I[0] = 10;
        I[1] = 20;
        int * p;
        p = &I[0];

        
        ++(*p)  => 11, changes I[0] to 11
        *(++p)  => 20, changes p to &I[1]
        (*p)++  => 10, changes I[0] to 11
        *(p++)  => 10, changes p to &I[1]


Macros/Preprocessor

    the preprocessor changes C source code into C source code
    
    #define SECRET 20
    
    #define MEAN(X, Y)  ((X)/2 + (Y)/2)

    
        MEAN(a, b)   => ((a)/2 + (b)/2)
        
        MEAN(a + b, c)  => ((a+b)/2 + (c)/2)
        1/MEAN(a, b)    => 1/((a)/2 + (b)/2)


    #define FOO(X)  ((X)++/2)
    
    
        FOO(bar)   => ((bar)++/2)


Posix File IO
-------------

C (and Posix) model files as a stream of bytes
=> actually, many things can be treated as streams of bytes
    Posix uses the file interface to deal with many of these
    
        files on disk (open())
            - can include many "non-file" file-like things
                FIFOs, devices, terminals
        pipes (pipe())
        terminals
        sockets (socket(), accept())

    different streams offer different operations
        read()
        write()
        lseek()
     
streams are identified by "file descriptors"
    -> numbers that index into a table of open streams

Posix file operations are "unbuffered"
    we provide our own buffer, and get data as soon as we ask for it
    
    char buf[200];
    read(fd, buf, 200);  <- obtain up to 200 bytes
    
    read() and write() return the number of bytes read/written
        -> why?
        


C file operations are "buffered"
    the FILE struct includes a buffer of data from the stream
    calls to fscanf() read from the buffer, and call read() internally to
        refresh it
    
    calls to fprintf() write to the buffer, and call write() internally to
        flush it



File system
-----------

Files are identified by i-node number (and device number)
    
    every file has exactly 1 i-node and zero or more data nodes
    
    i-node stores data about the file
        size
        who owns it
        what permissions it has
        where its data are stored
        
            -> direct and single/double/triple indirect references
            allows for very large files
            keeps i-nodes with a small, fixed size
            fast access to all parts of the file

    => not included: file name
    
directory hierarchy

    a directory file maps names to i-nodes
    
    starting from the root directory, we can define a path to a file
    
        /directory/subdirectory/subsubdirectory/name
        
        "directory" in /
        "subdirectory" in /directory
        "subsubdirectory" in /directory/subdirectory
        "name" in /directory/subdirectory/subsubdirectory

    each directory entry that references an i-node is a "link"
    the number of links to a file is the number of entries it has
    
    files can be linked any number of times
    
    every directory is linked in at least two places
        -> its parent (via its name)
        -> itself (via .)
        
        -> from each of its subdirectories (via ..)


Processes
---------

a process is an abstraction that executes a program
    -> a virtual memory (containing instructions)
    -> current processor state (program counter, registers, etc.)

    "program plus state"


processes are identified by process id (PID)

to create a new process, call fork()
    - duplicates current process
    - new process (child) starts with same state as parent
        -> is about to return from the call to fork()
        -> all data in memory is copied
        -> all open files are now open in the child (as well as in the parent)

    "fork returns twice"
    
    
    returns 0 in the child, returns PID of child in the parent
    
after calling fork(), parent should (eventually) call wait()
    -> learn that child has terminated
    -> obtain exit status of child


execv(), execl()
    - change the current program
    - start executing a new program; abandon the current program
    - memory is effectively cleared
    - retain PID
    - open files (mostly) remain open
    
    "exec does not return"
    
common pattern

    if (fork() == 0) {
        // set up some stuff with files
        execl(...)
    }
    wait()


Signals
-------

mechanism to interrupt a process
-> asynchronous communication with a process

signal types are identified by number (usually written as constants)
    SIGINT, SIGTERM, SIGKILL, SIGCHLD, etc.
    
can be triggered by errors or sent by other processes

a process sets a "disposition" for each signal type
one of:
    terminate
    ignore
    call a handler function
    stop
    continue


handler functions can stop the process (by calling exit()) or
resume executing from the point where the signal was received (by returning)

    -> it is only safe to resume from non-error signals


    signal handlers can only call a subset of "safe" functions


we can decide whether system calls resume or stop if we get a signal


signal mask
    - set of signals that are "blocked"
    
    blocked signals are not delivered, but also are not discarded
    if the signal is later unblocked, any pending signals will be delivered


Multithreading
--------------

allows us the benefits of multitasking within a single process
-> single shared memory


benefits: easier communication
drawbacks: more need for coordination

data race
    multiple threads access a piece of data and at least one access is
    a write
        (without coordination)
    
C programs containing data races are undefined

avoid data races by coordinating

e.g., use mutual exclusion to enforce sequential access
    -> no uncoordinated access means no data races
    -> still can have nondeterministic behavior
    

pthread library

    pthread_create()
    pthread_join()
    
    pthread_mutex_t  - used to coordinate exclusive access
    pthread_cond_t   - allows thread to block until another thread says
                        it can continue

    pthread_barrier_t
    sem_t


atomic instructions

    to implement mutex, we need a way to perform multiple memory operations 
    such that no other thread/CPU can access it "in between"
    
    test-and-set   - in one step, check whether an object has a certain
        value and set it to something
    compare-and-swap
    
    
    var M;
    
    if (test-and-set(M, 1) == 0) {
        // we know no other thread saw M was 0 before we could set it to 1
    }
    
    => without hardware support for atomic instructions, no coordination
        between threads is possible

deadlock: 4-necessary conditions
    mutual exclusion
    hold and wait
    no preemption
    circular wait


Networking
----------

sending messages from one process on one device to another process on
    a different device
    -> these devices may not be directly connected to each other
    
"link layer" - communication between directly connected devices
"network layer" - communication between devices on the same network
    (e.g., the Internet)
"transport layer" - communication between specific processes
"application layer" - the actual messages


sockets interface - used to establish communication by applications

    socket - identified by file descriptor
        abstract interface that may be connected to the network
        
    socket() - creates new (unconnected) socket
    
    connect() - connects a socket to a specified remote host/service
    
    bind() - connects a socket to a service on the local host
    listen() - indicates we want to accept incoming connection request
    accept() - waits for a connection request, returns a new socket
        handling the connection


there are many kinds of socket
sockets created with SOCK_STREAM will present a stream interface
    that can be used with read() and write()


    transport will ensure that bytes we send are received and that
    the bytes we receive are in the proper order and not missing anything

points to consider:
    avoiding blocking
    know where your message boundaries are
    
    know which party establishes the connection
    know how messages are encoded
    
OSI model
    physical
    data link
    network
    transport
    session
    presentation
    application



