CS 214 / Multithreading examples
================================

late submissions for project III will be accepted until next Monday

reminder: late submissions lose 10 points per day (rounded up)
    late penalties will not reduce your score below 60

Project IV is cancelled
    - instead, some exercises you can work on by yourself
    - the project will be repurposed for in-class examples

Final exam will be on-line via Canvas
    24-hour window
    primarily multiple choice


exercise: read/write lock
-------------------------

idea: we allow two kinds of access to a resource
    write access (exclusive)
    read access (non-exclusive)
    
operations
    init/destroy
    
    read_lock
        increases the number of threads with read access
        blocks if any thread has write access

    read_unlock
        decreases the number of threads with read access

    write_lock
        increases the number of threads with write access
        blocks if any thread has read or write access
        
    write_unlock
        decreases the number of threads with write access


data to track in your lock structure
    what sort of access is currently held
    how many threads have read access
    how many threads are waiting for write access
    a mutex and condition variables; or semaphores
    


starvation
----------

starvation occurs when a process is unable to acquire a resource, because
other processes keep acquiring it first

e.g., in a simple design for a read/write lock, reading threads can
    starve a writing thread
    
one solution: force some sort of turn-taking
    e.g., if a thread is waiting for write access, threads cannot acquire
        read access until the writer has had its turn


livelock
--------

two or more processes have incompatible prerequisites
    each process changes state for its own needs
    other processes undo these changes for their needs
    
    
    thread A            thread B
    --------            --------
    while X != 1        while X != 0
        X = 1               X = 0
    do stuff            do stuff
    
    


another thread-safe queue
-------------------------

scenario: multithreaded recursive directory traversal

idea:
    have a pool of directories to traverse
    each thread repeatedly:
        1. obtains a directory from the pool
        2. reads the entries in the directory
        3. adds any subdirectories to the pool
        4. continues until all directories have been traversed

    advantages of this approach:
        fixed number of threads
        finite number of directories open simultaneously
        even distribution of work among threads
        
questions to consider
    - can we use a bounded queue?
        no: this can deadlock if the queue is full
        
    - how do we know when we are finished?
        the pool is empty and all the threads are waiting for the pool
        (but if any thread is waiting the pool must be empty)
        
        
    typedef struct {
        char **paths;  // names of directories to traverse
        int itemcount;  // number of paths in the pool
        int arraysize;  // length of array
        int active;     // number of non-blocked threads
        pthread_mutex_t lock;
        pthread_cond_t nonempty;
    } pool_t;
    
    void pool_init(pool_t *p, int capacity, int threads)
    {
        ...
        p->active = threads;
        ...
    }
    
    void pool_add(pool_t *p, char *path)
    {
        pthread_mutex_lock(&p->lock);
        
        if (p->itemcount == p->arraysize) {
            p->arraysize *= 2;
            p->paths = realloc(p->paths, p->arraysize * sizeof(char *));
        }
        
        p->paths[p->itemcount] = path;
        p->itemcount++;
        
        pthread_cond_signal(&p->nonempty);
        
        pthread_mutex_unlock(&p->lock);
    }
    
    // return 1 on success, 0 on failure
    // on success, write the removed item to dst
    int pool_remove(pool_t *p, char **dst)
    {
        pthread_mutex_lock(&p->lock);
        
        if (p->itemcount == 0) {
            p->active--;
            
            if (p->active == 0) {
                pthread_cond_broadcast(&p->nonempty);
                pthread_mutex_unlock(&p->lock);
                return 0;
            }
            
            do {
                pthread_cond_wait(&p->nonempty, &p->lock);
                if (p->active == 0 && p->itemcount == 0) {
                    pthread_mutex_unlock(&p->lock);
                    return 0;
                }
            } while (p->itemcount == 0);
            
            p->active++;
        }
        
        p->itemcount--;
        *dst = p->paths[p->itemcount];
        
        pthread_mutex_unlock(&p->lock);
        
        return 1;
    }




int wstatus;

finished_child = wait(&wstatus);

success = WIFEXITED(wstatus) && WEXITSTATUS(wstatus) == 0;
