CS 214 / Signals
================

Interrupts
----------

normal CPU operation ("fetch-execute cycle")

    loop forever:
        fetch current instruction
        decode instruction
        execute instruction (and advance current instruction pointer)

interrupts break the CPU out of this cycle

    - save current state of the CPU
    - execute some other code (based on what sort of interrupt happened)
    - possibly resume what you were doing before


interrupts can happen at any time (asynchronous)

interrupts are used for:
    - preemptive multitasking
    - errors and exceptional conditions
        e.g., divide by zero, memory errors
    - arrival of input data
    - timers


Signals
-------

a way to send a message to a process asynchronously
a way for a process to indicate what should happen

several signal types
    - indicated by numbers
    - usually referred to by name


each process has a "disposition" for each signal type
    -> this says what to do when the signal arrives

for each signal type, there is a default disposition,
but processes can override it


dispositions:
    - ignore
    - terminate
    - terminate and dump core
    - stop
    - continue (a stopped process)
    - call a signal handler
        a regular function that is called when the signal arrives
        may return normally (continuing the program), exit, or jump
            somewhere else


signal types:
    man 7 signal

termination signals

SIGTERM   - default signal sent by kill command
SIGINT    - sent by terminal when user types ^C
SIGHUP    - sent when user logs out
SIGQUIT   - sent by terminal when user types a particular code
SIGABRT   - sent by abort()

SIGKILL   - sent by kill -KILL; cannot be blocked or ignored


SIGSTOP   - stops a process
SIGTSTP   - "typed stop"; sent by terminal when user types ^Z


SIGCONT   - continues a stopped process
SIGCHLD   - sent when a child process is terminated, stopped, or continued

error signals:

SIGFPE   - floating-point exception (sometimes integer div by 0)
SIGSEGV  - segmentation violation / segfault
SIGBUS   - bus error




changing disposition for a signal

#include <signal.h>

typedef void (*sighandler_t)(int);

sighandler_t signal(int signum, sighandler_t disposition);

    arguments are the signal number (use a constant) and the
        desired disposition
    returns the previous disposition
    
    special disposition values:
        SIG_IGN  - ignore
        SIG_DFL  - default
    
    it is recommended that you only use signal() with SIG_IGN or SIG_DFL



int sigaction(int signum, struct sigaction *new, struct sigaction *old);
    signum indicates the signal type
    new describes the action that we want
    old will contain the previous action
    
    struct sigaction {
        sighandler_t sa_handler;
        void (*sa_sigaction)(int, struct siginfo *, void *);
        sigset_t sa_mask;
        int sa_flags;
        ...
    }
    
    
    see man 7 sigaction for descriptions of the flags


Signal handlers
---------------

a signal handler is a function that is called asynchronously

the signal handling machinery will simulate a function call to the
handler when the signal arrives
    it gets space on top of the stack like a normal function
    if it returns, it jumps back to the instruction that was being
        executed when the signal arrives

the handler may be called at any point, including in library code
not all functions are "re-entrant"
    that is, they can't be called if they are already executing
    

you can only call functions that are signal safe/signal re-entrant

    man 7 signal-safety
    
    most C IO functions are not safe
    most system calls are safe (because they do their work in the OS)
    
general advice: do as little work in a signal handler as you can


questions to consider:
    what happens if you get a signal while you are executing a signal
        handler?


sigaction allows us to specify how to handle signals arriving during
    a signal handler
    - we can temporarily install a different handler 
    - we can temporarily block that signal (or others)
    - we can do nothing and see what happens


a process has a "signal mask" that indicates which signals are "blocked"

if we block a signal, any signals of that type are held in a queue
they get delivered when the signal is unblocked

use sigprocmask() to change the process's signal mask

sending signals
---------------

kill command sends signals to processes

    kill [-NAME] PID
    
        if we don't give a name, it sends SIGTERM
        

int kill(pid_t pid, int signum);

    sends a signal to the specified process
    
int raise(int signum);

    sends a signal to the current process
    
    
