CS 214 / Multithreading
=======================

Threading
---------

"tasks" - fetch-execute cycle
    - instruction pointer, usually a stack
    - can run concurrently, execute different programs


"process" - OS abstraction
    - one (or more) tasks
    - private virtual memory

multitasking - can run more than one task concurrently
multiprocessing - multiple processors, each executing a task


we can use processes for multitasking, but it can be inconvenient
communication is limited between processes
    - signals
    - read/write pipes
    - send data through file system
    
    
multithreading - more than one task in a single process
    "thread" - a task running in a multithreaded process
    
    threads in a process share the same virtual memory
    - shared memory greatly eases communication among tasks
    - coordination needed to avoid problems
        - violation of data structure invariants
        - nondeterministic behavior
        - "impossible" behavior

2 major kinds of multithreading systems

"OS threads"/"kernel threads"
    - rely on OS task scheduler
    - visible to OS
    - OS can schedule threads on different CPUs

"green threads"/"library threads"/"language threads"
    - created and managed by language run-time system
    - not visible to OS
    - usually lower overhead than kernel threads
    - can take advantage of language-specific information



Need for synchronization
------------------------

race condition 
    - outcome of program depends on which thread finishes first
    - behavior depends on scheduler
    
    
    Thread A        Thread B
    --------        --------
    X = 1           X = 2

After both threads have executed, what is the value of X?
    X will be either 1 or 2, depending on how the threads were scheduled
    instead of a single outcome, we have a set of possible outcomes
    

    Thread A        Thread B
    --------        --------
    X++;            X++;
    
X is initially 0. After both threads finish, what is X?
    it could be 1 or 2, since the increment may not be atomic


data race
    - occurs when multiple threads have unsynchronized access to
        a piece of data, and at least one thread writes
        
        
the behavior of C programs containing data races is undefined


    Thread A                            Thread B
    --------                            --------
    for (i = 0; i < 100; i++) {         X = 0;
        X = 1;
        A[i] = X;
    }

101 possible behaviors
    A is all 1
    A is all 1, except a single 0
    
    Thread A (optimized)
    --------------------
    X = 1;
    for (i = 0; i < 100; i++) {
        A[i] = X;
    }

101 possible behaviors
    A is all 1
    A is zero or more 1s followed by 0s
        -- 99 of these behaviors are new!
        
this optimization changes the possible behaviors, because of the data race
we want to allow this optimization, so instead we forbid data races


by synchronizing access to shared data, we eliminate data races



Tools for synchronization
-------------------------

memory fence
    instruction that pauses the current task until all its pending
    writes have completed
    
    hard to use optimally
    - too many fences slows your program
    - not using fences in the right places allows data races

    typically, memory fences are best left to experts
    library code will have the fences where they are needed/helpful

mutual exclusion / "mutex" / "locks"
    enforce sequential access to shared resources
    operations: lock and unlock
        one thread can "hold" the mutex at a time
        a thread trying to lock a locked mutex will block until the
            mutex is unlocked


let's write a lock

int lock = 0;  // shared across threads

operation:
    // acquire lock
    while (lock != 0) { // do nothing }
    lock = 1;
    
    // do stuff (critical section)
    
    // release lock
    lock = 0;
    
but the acquisition part doesn't provide safety
    another thread could execute between the loop and the assignment!
    problem is that the check and the assignment are not atomic
    
hardware must provide an atomic operation
    test-and-set
    compare-and-swap
    fetch-and-add

we can imagine test-and-set as a function that sets a variable to 1
and returns its previous value, atomically

    while (test_and_set(&lock) != 0) { // spin }
    
    // do stuff (critical section)
    
    lock = 0;

