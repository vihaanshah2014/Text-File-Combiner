CS 214 / StrBuf and make
===========================

Project I will be posted later tonight (or early tomorrow)
We will discuss the content of Project I on Wednesday

Recitations will start on Wednesday


StrBuf
------

a stretchable character array with efficient append

data structure
- backing array (identity of array may change over time)
- size of backing array (array capacity)
- size of the string


operations
- add a character
- append a string
- initialize
- destroy



files:
strbuf.c   - implementation of functions
strbuf.h   - type definitions and function prototypes
driver.c   - client code

    driver.c includes strbuf.h (to that it has the prototypes)
    strbuf.c includes strbuf.h (ensure prototypes are consistent)
    
compilation process
    compile strbuf.c to strbuf.o
    compile driver.c to driver.o
    link strbuf.o and driver.o into driver
    

expanding the array
1. use malloc() to allocate a bigger array
2. use memcpy() to move current array to new array
3. use free() to deallocate the original array

... but realloc() does all these

void *realloc(void *, size_t);

    we provide a pointer to an object (or NULL) and a desired size
    if it can, realloc will make the object bigger
    if it can't, realloc will do the steps listed above
    
realloc() returns a pointer to the object, which may have moved
-> we have to assume that it has moved

common usage pattern
    p = realloc(p, new_size);
    
but this causes problems if realloc fails (and returns NULL)

safer pattern:
    void *q = realloc(p, new_size);
    if (q == NULL) { // report error or something }
    else p = q;
	
	
	
make
----

tool to automate compiling (building) large projects

you create a make file that says how to create certain files

<file name>: <list of dependencies>
	<commands to create file>
	<or just do something>
	
commands must be indented by a single tab character -- no spaces!


strbuf.o: strbuf.c strbuf.h
	gcc -c strbuf.c
	
driver.o: driver.c strbuf.h
	gcc -c driver.c

driver: driver.o strbuf.o
	gcc driver.o strbuf.o -o driver


when we ask make to create a target, it:
1. checks whether dependencies are up to date
2. checks whether the target is newer than its dependencies
3. if the target is older than at least one dependency, run the commands


we can call make with zero or more arguments
with one or more arguments, make will build all the specified targets
with no arguments, make builds the first target in the file

    -> typically, we would put the rule for the program first
    -> then we can just type 'make' to recompile everything

make -B <args>
	run as though everything is out of date


variables in makefiles
----------------------

to define a variable

VAR_NAME = some text

to use a variable
	$(VAR_NAME)
	
commonly used variables

CC = gcc
CFLAGS = -g -Wall -std=c99 -fsanitize=address -O2


driver: driver.o strbuf.o
	$(CC) $(CFLAGS) driver.o strbuf.o -o driver

driver.o: driver.c strbuf.h
	$(CC) $(CFLAGS) -c driver.c

strbuf.o: strbuf.o strbuf.h
	$(CC) $(CFLAGS) -c strbuf.c


make has a built-in rule to create a .o file from a .c file


generalized recipes
-------------------

we get three more variables when executing a recipe

    $@ - name of the target
    $^ - list of dependencies
    $< - first dependency
	

wildcard recipes

%.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@


we can use recipes with no commands to indicate extra dependencies

driver.o: strbuf.h
strbuf.o: strbuf.h

or combine them

driver.o strbuf.o: strbuf.h











	






	
