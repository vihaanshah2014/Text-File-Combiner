CS 214 / Directories
====================

Recap:
    a directory is a special file that contains directory entries
    each directory entry has (at a minimum)
        - file name
        - inode identifier

    every directory has two special entries
        .   - always refers to the directory itself
        ..  - always refers to the parent of the directory
        
two ways to open a directory file

    open()  - gives access to the raw bytes (not usually necessary)
    
    opendir()  - convenient way to iterate through directory entries
    
#include <dirent.h>

DIR *opendir(char *path);

    opens the specified directory and returns a handle
    on failure, returns NULL and sets errno
    
struct dirent *readdir(DIR *handle);

    returns the next entry in the directory
    returns NULL if we have read all the entries
    
    struct dirent contains at least these fields
        int_t d_ino;    // i-node identifier
        char d_name[];  // file name (null-terminated string)
        
    the pointer we get is only valid until the next call to readdir()
        or a call to closedir()

int closedir(DIR *handle);

    closes the specified open directory
    returns -1 and sets errno on failure



note: readdir() returns entries in no particular order
    (possibly the order that entries are stored in the directory file)


stat
----

int stat(char *path, struct stat *data);

    on success, fills out the specified struct with info about the file
    on failure, returns -1 and sets errno
    
    
struct stat contains information about the file, including
    dev_t st_dev;   // id of the device containing the file (disk)
    int_t st_ino;   // inode identifier for the file
    mode_t st_mode; // mode information (permissions, etc)


using the mode, we can learn things about the file including
    permissions
    file type
    
    
    S_ISREG(m)   - true for regular files
    S_ISDIR(m)   - directories
    S_ISLNK(m)   - symbolic links
    
struct stat sbuf;

int r = stat(pathname, &buf);
if (r < 0) { ... }

if (S_ISREG(buf.st_mode)) {
    // regular file
} else if (S_ISDIR(buf.st_mode)) {
    // directory
} else {
    ...
}

reference
    man 2 stat
    man 7 inode


the shell
---------

shell commands start with the command name
    bare name - look for a program in the specified directories
    path      - indicates a specific program

    cp  - will be found in /usr/bin
    /usr/bin/cp  - absolute path indicating program
    ./cp  - relative path (indicating cp in the working directory)
    
shell wildcards

    ?  - wildcard that can be replaced by any character
    *  - any sequence of zero or more characters (excluding /)
    
the shell replaces words containing a wildcard with files matching
    the word
    
example: current directory contains a.txt, b.txt, cd.txt

    ls ?.txt
        shell replaces this with
    ls a.txt b.txt
    
    ls *.txt
        shell replaces this with
    ls a.txt b.txt cd.txt

./spchk dict foo*.txt  

 subdir/*.c 
 
 subdir/*/*.c
 
 
 
mv <old_name> <new_name>

    either renames the first file or moves the file (if the new name is
        an already existing directory)

mv <many names...> <destination directory>


implication: we can't rename multiple files at once

    mv *.c *.cpp
        doesn't work!
        can't work!




    

    
    






