CS 214 / C Intro/Review
=======================

Office hours: Hill 448
    Monday/Thursday, 2:00 PM - 4:00 PM


declarations and definitions
----------------------------

a declaration describes something
    a function prototype gives the signature of a function
        return type and number and type of arguments
    a global variable declaration says the type of the global variable

a definition creates something
    function definition
    global variable definition

anything we want to use must be defined exactly once
    cannot have two variables/functions with the same name

we can declare something as many times as we want
    - as long as the declarations are consistent
    - every definition is implicitly a declaration

we cannot refer to anything unless it has been declared earlier in the same
file

example: mutual recursion
    void bar(void);     // declares bar but does not define it
    void foo() {  ... bar() ... }
    void bar() {  ... foo() ... }


example: functions defined in other files
    one file, queue.c, contains functions that work with a data structure
    one file, main.c, uses those functions

    problem: we call functions from queue.c in main.c, but main.c
        does not define them
    solution: we declare them in main.c

compiling main.c and queue.c will produce "object files"
    main.o and queue.o
    these contain "unresolved symbols"
        functions are called by name, not by address
        
    the linker will resolve these symbols when creating the executable

header files
------------

a C source file containing declarations
    queue.h
    stdlib.h, stdio.h, unistd.h, string.h, pthread.h
    
these contain
    function prototypes
    global variable declarations (using extern)
    type declarations
    macros (more on that later)
    
these must not contain definitions!
we expect them to be included in multiple source files


example program
    library: queue.c and queue.h
    client: main.c (inclues queue.h)
    
    gcc -c main.c
        -> produces main.o
    
    gcc -c queue.c
        -> produces queue.o
    
    gcc main.o queue.o -o program
        -> produces program



the preprocessor
----------------

this is a program that runs before compilation and modifies your
source code

we control the preprocessor with preprocessor directives
    lines that begin with #

#include <stdio.h>
#include "queue.h"

these tell the preprocessor to include the contents of the specified file
in the source file before compiling

    use <> to indicate a file in the standard include directories
    use "" to indicate a file in the working directory


#include is usually used to include header files, but any file can
be included


macros: tells the preprocessor to replace text in our code

#define MACRO "hello"

    a #define directive adds a macro definition and its replacement
    it will apply to the remainder of the file
    
    puts(MACRO)
    =>
    puts("hello")
    
the preprocessor only replaces complete tokens
    puts(MACROS)
    =>
    puts(MACROS)

the preprocessor does not replace inside string literals

    puts("MACROS")
    =>
    puts("MACROS")
    
    
use macros to define constants
don't use "magic numbers"!


#define ARRAYLENGTH 100

{
    int array[ARRAYLENGTH];
    for (i = 0; i < ARRAYLENGTH; i++) {  ... }
    ...
}


macros replace source code, not values

#define OK     != -1

    if (myfunction() OK) { ... }
    

macros can have parameters

#define check(X)  if ((X) == -1) { puts("Oh no!"); exit(1); }

    check(some_function(arg1, arg2))
    =>
    if ((some_function(arg1, arg2)) == -1) { puts("Oh no!"); exit(1); }
    

#define foreach(P)    for( ; P; P = P->next)

    struct node *p = ...
    
    foreach(p) { stuff involving p }
    =>
    for( ; p; p = p->next) { stuff involving p }
    

#define SQUARE(X)   X * X

    SQUARE(q)
    =>
    q * q
    
    1/SQUARE(a+b)
    =>
    1/a+b*a+b
    
    
#define SQUARE(X)   ((X) * (X))

    1/SQUARE(a+b)
    =>
    1/((a+b) * (a+b))


#undefine ARRAYLENGTH
    removes the definition of the macro for the remainder of a file



conditional compilation:
    include multiple versions of a program/code fragment and select
    which one to use
    

#ifdef SOME_MACRO

    code to use if SOME_MACRO is defined
    
#else

    code to use if SOME_MACRO is not defined
    
#endif


#ifndef SOME_MACRO

    code to use if SOME_MACRO is not defined
    
#endif


#if OS_VERSION < 10

    code to deal with old OS
    
#endif


#ifndef DEBUG
#define DEBUG 0
#endif

if (DEBUG) printf("the value of x is %d\n", x);


defining a macro on the command line
gcc -D<macro_name>
gcc -D<macro_name>=<value>
    these instruct the preprocessor to start with these macros defined
    


#define malloc(X) glorb(X)
#include <stdlib.h>
    whoops, now malloc() is undeclared
    

surprisingly, this sort of thing has non-terrible uses as well
-> look up "feature test macros"

