CS 214 / You, your malloc, and you
==================================

Recitations started tonight
Project I group sign-up sheet on Canvas


mymalloc and myfree
- take additional arguments: file name and line number
    these are used to provide more informative error messages
    
    free: attempt to free non-object (file.c:123)
    

- provided malloc() and free() macros will automatically fill in
    the file name and line number arguments
        
    preprocessor replaces
        __FILE__ with a string literal containing the file name
        __LINE__ with an integer literal that is the line number


internally, your library will use a static global array as its heap

#define MEMSIZE 512

static double memory[MEMSIZE];

"static" keyword makes the global variable private to this source file
    it does not participate in linking
    -> prevents other code from touching our variable
    
"double" has no significance, aside from ensuring 8-byte alignment
    -> we will not use this as an array
    
alignment:
    primitive N-byte data should be at addresses divisible by N
    - ensures that data is stored in a single cache line
    - ensures that two primitive data items will not overlap
    
- how does malloc() deal with alignment?
    knowing the size of an object does not tell us its alignment
    malloc(40)
        could be
            5 doubles (alignment 8)
            10 integers (alignment 4)
            20 shorts (alignment 2)
            40 chars (alignment 1)
    we are not allowed to use unaligned pointers in C (undefined behavior)
    how can malloc know the alignment of the data?
    it can't! it just guarantees the largest alignment for the hardware


how to round up to a multiple of 8

    7   - all zeros followed by 3 ones
    ~7  - all ones followed by three zeros
    
    n & ~7  - n rounded down to the nearest multiple of 8
    
    (n + 7) & ~7   - n rounded up to the nearest multiple of 8
    

errors to detect

1. malloc way too much memory
2. malloc more memory than any available free block

3. free an object not in the heap
4. free an object that is already free
5. free a pointer not at the start of an object




#define heap ((char *) memory)

to get a pointer at n bytes into the heap, write heap + n


we can cast pointers at will

    ((struct header *) (head + offset))->size
    
    
#define blocksize(offset)   *(int *)(((char *) memory) + offset)
#define allocated(offset)   *(int *)(((char *) memory) + offset + 4)
    
    int offset = 0;
    
    size = blocksize(offset);
    
    offset += blocksize(offset);



testing strategy

1. figure out required properties of your library
    "when malloc allocates an object, it does not overlap any other object"
2. figure out how to know if these properties have been violated
    "writing to one object should not change the contents of any other object"
3. write test cases to try to cause violations
    memtest.c
    
having a well thought-out test plan is essential for writing complicated
    software

