CS 214 / Processes
==================

Midterm Exam: Wednesday, March 6, in class
    I will post a topic list and discuss it Monday
    You may bring 1 page (single sided) of handwritten notes
    
Format: primarily short answer questions (a few sentences at most)
    Some code reading, very little code writing


Project II will be due March 18


shell
-----

recall:
    search path used for first word in command (except for paths)
    
        prog    run a program "prog" in the search directories
        ./prog  run a program "prog" in the working directory

    PATH is the list of directories to search for programs


file globs
    specify one or more files
    
    * matches any sequence of characters
    ? matches any one character
    
    the shell expands globs before executing the program
    

stdin, stdout, stderr
    normally, these files are inherited from the shell 
        (or other parent process)
    
    redirection lets us change these
    
    some_program < foo
        use the file "foo" as standard input
        
    some_program > bar
        use the file "bar" as standard output
    
    some_program < foo > bar
        use "foo" as stdin and "bar" as stdout
    
    some_program >> bar
        use "bar" as stdout in append mode
        
    
    some_program 2> errs
        use "errs" as stderr
    
    some_program 3< foo 4> bar
        open "foo" for input as file number 3
        open "bar" for output as file number 4
        

## pipes

use pipes to chain two or more programs together,
    where the output of one program becomes the input of the next


    some_program | grep ERROR
    
        runs some_program and grep
        stdout for some_program writes to stdin for grep
        
    some_program | grep ERROR | sort | uniq -c


    some_program | tee file
    
        tee reads from stdin (the output of some_program)
        it sends what it reads to the file and to stdout

useful programs

wc - counts characters/words/lines in a file 

cat   - reads several files and writes them to stdout
more  - reads from a file or stdin and paginates its output
less  - more powerful version of more (lets you go backward)


    cat *.c | grep foo

    cat chapter*.txt > whole_thing.txt
    
grep - search files (or stdin) for lines matching a pattern

    grep ERROR files...
        print all lines containing ERROR    
    grep ^ERROR
        print all lines beginning with ERROR
    
    grep 'foo.*bar' files
        print lines containing "foo" followed at some point by "bar"

    grep "[0-9]" files
        print lines containing a digit

grep regular expressions are very powerful
many tutorials exist on-line


## exit status

    $?   - shell variable containing the exit status of the last process
    

foo && bar

    executes foo
    if foo succeeded, executes bar

    make prog && ./prog

foo || bar

    executes foo
    if foo failed, executes bar
    
    ./prog || echo "Failure!"
    

processes
---------

a process is a program that is being executed
    
    a process includes the state of the computer (memory, files, etc)
        as well as a program it is executing

    every process has a unique process ID (PID)
    

in Unix, a process group is a collection of one or more processes
    a process group created by a shell is a "job"
    
    running a single program starts a job
    all processes in a pipeline are part of the same job
    

a session is a set of process groups
    typically, each time you log into a system, you get a new login session
    every job and process you start will be part of this session


    a login session can be associated with a terminal
    
process groups can be in the foreground or the background


useful control codes:
    ^C   interrupts (terminates) every process in the foreground
        process group
    ^Z   stops (pauses) every process in the foreground progress group
        the parent becomes the foreground
        
        
fg   - brings a stopped job back to the foreground
bg   - resumes a stopped job in the background


jobs - lists all active jobs with their status
ps   - lists all processes in the current session

    ps -e   - lists all processes

put & at the end of a shell command to start the job in the background

    long_program > lp.out & 
    

    gedit file.c &
        <- run gedit in the background, so you can still use the shell


kill
    sends a signal to a process
    
    by default, sends TERM (tell process to terminate)

kill -KILL
kill -9
    kills a process with no opportunity to block


what happens to processes running in the background when I log out?

    they are sent HUP ("hang up")
    by default, a process receiving HUP will terminate

nohop shell command
    runs the shell command but blocks the hang-up signal
    
    nohup ./test_server
    

note: HUP, INT, TERM, and KILL terminate a program
    STOP stops a program
    a stopped program can be resumed, a terminated program cannot


creating processes
------------------

pid_t fork(void);

    creates an identical duplicate of the current process
    in the original process, fork() returns the PID of the new process
    in the child process, fork() returns 0


pid_t child = fork();
if (child == 0) {
    // we are in the child
    ...
    exit()
}

// we are in the parent


the child process begins as a duplicate of the parent:
    same program
    same contents of memory
    same instruction pointer 
    same open files
    different process ID
    
once fork returns, the parent and child will (most likely) diverge


after calling fork(), the parent must (eventually) call wait()

pid_t wait(int *wstatus);

    blocks until a child terminates
    returns PID of the child that terminated
    if we give it a pointer, it will write an int containing the exit status
    

puzzle:

    what does this do?
    
    for (int i = 0; i < 5; i++) {
        fork();
    }
    

    why is this a terrible idea?
    
    while (1) {
        fork();
    }







