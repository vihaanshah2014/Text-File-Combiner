CS 214 / Condition variables
============================

mutex - abstraction used to coordinate exclusive access to resources
    "locked"   - exactly one thread has access
    "unlocked" - no thread has access
    
    a thread trying to lock a locked mutex will block, until the
        thread that locked the mutex unlocks it
        
    only the thread that locked the mutex can unlock it
    

using mutex, we can arrange sequential access to shared data structures

    "can arrange", not "enforce"
        you have to play by the rules to get safety



example: thread-safe queue

    enqueue
    dequeue
    
        -> what should happen if we dequeue from an empty queue?
        we could report that the queue is empty
            -> but it may not stay empty
        
        we don't want to keep trying to dequeue hoping for success
            "busy waiting"
            increases contention of the mutex
            
        we could wait for another thread
            but how long?
            
condition variable - allows a thread to block until something happens
    normally associated with a (specific) mutex
    while the thread is blocked, it unlocks the mutex
    when the thread proceeds, it relocks the mutex


pthread_cond_t - abstract condition variable type

int pthread_cond_init(pthread_cond_t *cv, pthread_condattr_t *attr);
int pthread_cond_destroy(pthread_cond_t *cv);


int pthread_cond_wait(pthread_cond_t *cv, pthread_mutex_t *lock);
    blocks current thread and releases lock
    reacquire the lock when resuming

int pthread_cond_signal(pthread_cond_t *cv);
    wakes one thread currently waiting for cv

int pthread_cond_broadcast(pthread_cond_t *cv);
    wakes all threads currently waiting for cv

    "spurious wakeup"

C1                  P1                      C2
dequeue
-> wait for
    read_ready

                    enqueue
                    ->signal
                        read_ready
unblocks
                                            dequeue
                                            -> length = 0

regain lock
-> queue empty!



engineering tradeoffs:
    how many mutexes do we need?
    what should be exclusive?
    
    too few mutexes can increase contention
        -> less ability for threads to run concurrently
    
    too many mutexes may lead to unsafety
        -> deadlock
        -> not actually guaranteeing sequential access (data races!)
        -> lots of time locking and unlocking



reasoning about sequential data structures can be hard!
    need to consider many worst-case scenarios
    anything that can possibly go wrong will go wrong

